{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"final",
				"final_result_ieee"
			],
			[
				"NRM",
				"NRM_STAGE"
			],
			[
				"over",
				"overflow"
			],
			[
				"ARR",
				"Array_IN_3"
			],
			[
				"Ope",
				"Operand1_W"
			],
			[
				"Da",
				"Data_X"
			],
			[
				"log",
				"logVectorReference"
			],
			[
				"beg",
				"begin\tbegin"
			],
			[
				"ena",
				"enable_Pipeline_input"
			],
			[
				"SGF",
				"SFG_ACTIVE"
			],
			[
				"SHT2",
				"SHT2_ACTIVE"
			],
			[
				"SHT",
				"SHT1_ACTIVE"
			],
			[
				"EXP",
				"EXP_ACTIVE"
			],
			[
				"Theoretical_result_",
				"Theoretical_result_exponent"
			],
			[
				"un",
				"underflow_flag_t"
			],
			[
				"L",
				"L_limit"
			],
			[
				"under",
				"underflow_flag"
			],
			[
				"Sign",
				"Sign1"
			],
			[
				"Ex",
				"Exponent1_EW"
			],
			[
				"dia",
				"display"
			],
			[
				"be",
				"begin\tbegin"
			],
			[
				"M",
				"Mantissa_M"
			],
			[
				"re",
				"reg"
			],
			[
				"SW",
				"SW-1"
			],
			[
				"zero",
				"zero_flag"
			],
			[
				"ZERO",
				"ZERO_FLAG_SHT2"
			],
			[
				"reg",
				"register\t: w bit d register "
			],
			[
				"Comp",
				"Comparator_Less"
			],
			[
				"SWR",
				"SWR-1"
			],
			[
				"Compara",
				"Comparators"
			],
			[
				"Mul",
				"MultiplexTxT"
			],
			[
				"in",
				"include"
			],
			[
				"W",
				"W-2"
			],
			[
				"DMP_exp",
				"DMP_exp_NRM2"
			],
			[
				"EW",
				"EW-1"
			],
			[
				"EWR",
				"EWR-1"
			],
			[
				"LZ",
				"LZD_output"
			],
			[
				"fi",
				"final_result_ieee_o"
			],
			[
				"mux",
				"mux_sel_norm"
			],
			[
				"LZD",
				"LZD_output"
			],
			[
				"ADD",
				"ADD_OVRFLW_SGF"
			],
			[
				"INPUT",
				"INPUT_ACTIVE"
			],
			[
				"d_ff3",
				"d_ff3_LUT_out"
			],
			[
				"d_ff2",
				"d_ff2_Z"
			],
			[
				"para",
				"parameter"
			],
			[
				"rea",
				"ready_cordic"
			],
			[
				"CO",
				"CORDIC_Arch2"
			],
			[
				"al",
				"always\talways"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "//==================================================================================================\n//  Filename      : CORDIC_Arch3.v\n//  Created On    : 2016-09-28 14:58:46\n//  Last Modified : 2016-09-28 15:00:17\n//  Revision      :\n//  Author        : Jorge Sequeira Rojas\n//  Company       : Instituto Tecnologico de Costa Rica\n//  Email         : jsequeira@gmail.com\n//\n//  Description   :\n//\n//\n//==================================================================================================\n//==================================================================================================\n\n\n`timescale 1ns / 1ps\n\n\nmodule CORDIC_Arch3 #(parameter W = 32, parameter EW = 8, parameter SW = 23, parameter SWR=26, parameter EWR = 5)//*/\n/*#(parameter W = 64, parameter EW = 11, parameter SW = 52, parameter SWR = 55, parameter EWR = 6) //-- Double Precision */\n(\n//Input Signals\ninput wire clk,                         //  Reloj del sistema.\ninput wire rst,                         //  Señal de reset del sistema.\ninput wire beg_fsm_cordic,              //  Señal de inicio de la maquina de estados del módulo CORDIC.\ninput wire ack_cordic,                  //  Señal de acknowledge proveniente de otro módulo que indica que ha recibido el resultado del modulo CORDIC.\ninput wire operation,                   //  Señal que indica si se realiza la operacion seno(1'b1) o coseno(1'b0).\n\ninput wire [W-1:0] data_in,             //  Dato de entrada, contiene el angulo que se desea calcular en radianes.\ninput wire [1:0] shift_region_flag,     //  Señal que indica si el ángulo a calcular esta fuera del rango de calculo del algoritmo CORDIC.\ninput wire [1:0] r_mode,\n\n//Output Signals\noutput wire ready_cordic,                // Señal de salida que indica que se ha completado el calculo del seno/coseno.\noutput wire overflow_flag,                  //  Bandera de overflow de la operacion.\noutput wire underflow_flag,                 //  Bandera de underflow de la operacion.\noutput wire [W-1:0] data_output          // Bus de datos con el valor final del angulo calculado.\n);\n\nlocalparam d_var = 0;                      //   Valor por defecto que se le carga al contador de variables.\nlocalparam d_iter = 0;                  //  Valor por defecto que se le carga al contador de iteraciones.\n//localparam mode = 1'b0;\nlocalparam iter_bits = 4;                  //Modificar valor para obtener diferente cantidad de iteraciones; ejem= 3=8iter, 4=16iter. etc\n\nwire [W-1:0] x0,y0;\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngenerate\n    case(W)\n\n    32:\n    begin\n        assign x0 = 32'h3f1b74ee;                 //    x0 = 0.607252935008881, valor inicial de la variable X.\n        assign y0 = 32'h00000000;                 //    y0 = 0, valor inicial de la variable Y.\n    end\n\n    64:\n    begin\n        assign x0 = 64'h3fe36e9db5086bc9;        // x0 = 0.607252935008881, valor inicial de la variable X.\n        assign y0 = 64'h0000000000000000;        // y0 = 0, valor inicial de la variable Y.\n    end\n\n    default:\n    begin\n        assign x0 = 32'h3f1b74ee;                   //    x0 = 0.607252935008881, valor inicial de la variable X.\n        assign y0 = 32'h00000000;                   //    y0 = 0, valor inicial de la variable Y.\n    end\n    endcase\nendgenerate\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n//Signal declaration\n\nwire reset_reg_cordic;\n\n//ENABLE\nwire enab_d_ff_RB1;                                         //  Enable de la primera linea de registros.\nwire enab_d_ff2_RB2;                                        //  Enable de la segunda linea de registros.\nwire enab_RB3;                                              //  Enable del registro que guarda el valor del signo, dependiendo del modo del algoritmo.\nwire enab_d_ff4_Xn, enab_d_ff4_Yn, enab_d_ff4_Zn;           //  Enable de los registros que guardan los datos provenientes del modulo de suma/resta.\nwire enab_d_ff5_data_out;                                   //  Enable del registo que guarda el valor de salida final, listo para enviarse al procesador.\nwire enab_cont_iter, enab_cont_var;                         //  Enable de los contadores de variable e iteracion\nwire load_cont_iter, load_cont_var;                         //  Señal de carga de un valor en los contadores de variable e iteraciones.\nwire enab_dff_5;\n\n\n\n//SELECTION\nwire sel_mux_1, sel_mux_3;                                  //  Señales de seleccion provenientes de la maquina de estados.\nwire [1:0] sel_mux_2;                                       //  Señal de seleccion que se activa dependiendo de la variable que se este calculando.\n\nwire sel_mux_1_reg, sel_mux_3_reg;                          //  Señales de seleccion provenientes de la maquina de estados.\nwire [1:0] sel_mux_2_reg;                                   //  Señal de seleccion que se activa dependiendo de la variable que se este calculando.\n\n//DATA WIRES\nwire d_ff1_operation_out;                                   //  Salida del registro que guarda el dato de entrada de la operacion a realizar, coseno(1'b0) o seno(1'b1)\nwire [1:0] d_ff1_shift_region_flag_out;                     //  Salida del registro que guarda el dato de entrada que indica si el ángulo a calcular esta fuera del rango de calculo del algoritmo CORDIC.\nwire [W-1:0] d_ff1_Z;                                       //  Salidas de los registros que guardan los valores iniciales de las variables X, Y y Z.\nwire [W-1:0] d_ff_Xn, d_ff_Yn, d_ff_Zn;                     //  Salidas de los registros que guardan los valores de las variables X, Y y Z despues de cada iteracion.\nwire [W-1:0] first_mux_X, first_mux_Y, first_mux_Z;         //  Salidas de los mux que escogen entre un valor inicial y el valor obtenido en una iteracion.\nwire [W-1:0] d_ff2_X, d_ff2_Y, d_ff2_Z;                     //  Salidas de los registros que guardan los valores provenientes de la primera linea de mux.\nwire sign;                                                  //  Salida del mux que escoge entre el signo de Y o Z, dependiendo del modo, ya sea rotacion o vectorizacion.\nwire [W-1:0] data_out_LUT;                                  //  Salida del modulo generate que genera la LUT necesaria dependiendo del ancho de palabra.\nwire [iter_bits-1:0] cont_iter_out;                         //  Salida del contador que cuenta las iteraciones realizadas.\nwire [EW-1:0] sh_exp_x, sh_exp_y;                           //  Salidas de los sumadores de punto fijo que realizan los desplazamientos.\nwire [W-1:0] d_ff3_sh_x_out, d_ff3_sh_y_out;                //  Salida del registro que guarda el valor de X y Y luego de realizar los desplazamientos.\nwire [W-1:0] d_ff3_LUT_out;                                 //  Salida del registro que guarda el valor de la LUT.\nwire d_ff3_sign_out;                                        //  Salida del registro que guarda el valor del signo.\nwire [1:0] cont_var_out;                                    //  Salida del contador que cuenta las variables calculadas.\nwire [W-1:0] mux_sal;                                       //  Salida del mux final para colocar en la salida el valor deseado.\nwire [W-1:0] data_output2;                                  //  Salida del registro antes del cambio de signo.\nwire [W-1:0] sign_inv_out;                                  //  Salida del modulo de inversion de signo, dependiendo de si se el angulo de entrada estaba fuera del rango de calculo del algoritmo CORDIC.\nwire min_tick_iter,max_tick_iter;                           //  Señales que indican cuando se ha alcanzado el valor mas bajo y masalto de cuenta, correspondientemente en el contador de iteraciones.\nwire min_tick_var,max_tick_var;                             //  Señales que indican cuando se ha alcanzado el valor mas bajo y masalto de cuenta, correspondientemente en el contador de variables.\nwire enab_reg_sel_mux1,enab_reg_sel_mux2,enab_reg_sel_mux3;\nwire ready_add_subt;                                        //  Señal que indica que se ha realizado la operacion de suma/resta en punto flotante.\nwire [W-1:0] result_add_subt;                               //  Dato de entrada, contiene el resultado del módulo de suma/resta.\nwire beg_add_subt;                                          //  Señal de salida que indica que se debe de iniciar el modulo de suma/resta.\nwire ack_add_subt;                                          //  Señal que le indica al modulo de suma/resta que se recibio el resultado de este modulo correctamente.\nwire op_add_subt;                                           //  Señal hacia el módulo de suma/resta que indica si se va a realizar una suma(1'b0) o una resta(1'b1).\nwire [W-1:0] add_subt_dataA;                                //  Bus de datos hacia el modulo de suma/resta con el valor al que se le desea aplicar dicha operacion.\nwire [W-1:0] add_subt_dataB;                                //  Bus de datos hacia el modulo de suma/resta con el valor al que se le desea aplicar dicha operacion.\n\n//Instanciación\n//------------------------------------------------------------------------------------------------------------------------\n//FSM\n\nCORDIC_FSM_v2 cordic_FSM\n(\n.clk(clk),                                          //  Reloj del sitema.\n.reset(rst),                                        //  Reset del sitema.\n.beg_FSM_CORDIC(beg_fsm_cordic),                                //  Señal de inicio de la maquina de estados.\n.ACK_FSM_CORDIC(ack_cordic),                                //  Señal proveniente del modulo que recibe el resultado, indicado que el dato ha sido recibido.\n.operation(d_ff1_operation_out),                                    //  Señal que determina si lo que se requiere es realizar un coseno(1´b0) o seno (1'b1).\n.exception(1'b0),\n.shift_region_flag(d_ff1_shift_region_flag_out),                        //  Señal que indica si el angulo a calcular se encuentra fuera del rango de calculo del algoritmo CORDIC.\n.cont_var(cont_var_out),                                //  Señal que indica cual varible se va a calcular. Proveniente del contador de variables.\n.ready_add_subt(ready_add_subt),                                //  Señal proveniente del módulo de suma/resta, indica que se ha terminado la operacion y que se puede disponer del resultado de dicho modulo.\n.max_tick_iter(max_tick_iter),\n.min_tick_iter(min_tick_iter),              //  Señales que indican la maxima y minima cuenta, respectivamente, en el contador de iteraciones.\n.max_tick_var(max_tick_var),\n.min_tick_var(min_tick_var),                    //  Señales que indican la maxima y minima cuenta, respectivamente, en el contador de variables.\n\n//Output Signals\n.reset_reg_cordic(reset_reg_cordic),\n.ready_CORDIC(ready_cordic),                                //  Señal que indica que el calculo CORDIC se ha terminado.\n.beg_add_subt(beg_add_subt),                                //  Señal que indica al modulo de suma/resta que inicie su operacion.\n.ack_add_subt(ack_add_subt),                                //  Señal que le indica al modulo de suma/resta que se ha recibido exitosamente el resultado que este entrega.\n.sel_mux_1(sel_mux_1),\n.sel_mux_3(sel_mux_3),                      //  Señales de seleccion de mux, la primera escoge el canal 0 si es la primera iteracion, en otro caso escoge el canal 1, y la segunda escoge cual variable (X o Y) debe aparecer a la salida.\n.sel_mux_2(sel_mux_2),                              //  Señal de seleccion de mux, que escoge entre X, Y o Z dependiendo de cual variable se deba calcular en ese momento.\n.enab_cont_iter(enab_cont_iter),\n.load_cont_iter(load_cont_iter),                //  Señales de habilitacion y carga, respectivamente, en el contador de iteraciones.\n.enab_cont_var(enab_cont_var),\n.load_cont_var(load_cont_var),              //  Señales de habilitacion y carga, respectivamente, en el contador de variables.\n.enab_RB1(enab_d_ff_RB1),\n.enab_RB2(enab_d_ff2_RB2),                          //  Señales de habilitacion para los registros de variables de entrada y para los valores de las variables despues de los primeros mux, respectivamente.\n.enab_d_ff_Xn(enab_d_ff4_Xn),\n.enab_d_ff_Yn(enab_d_ff4_Yn),\n.enab_d_ff_Zn(enab_d_ff4_Zn),   //  Señales de habilitacion para los registros que guardan los resultados de cada variable en cada iteracion provenientes del modulo de suma/resta.\n.enab_d_ff_out(enab_d_ff5_data_out),\n.enab_dff_5(enab_dff_5),                    //  Señales de habilitacion para los registros en la salida, el primero antes del cambio de signo y el segundo es el que se encuentra en la salida.\n.enab_RB3(enab_RB3),                    //  Señales de habilitacion para los registros  que guardan los valores provenientes de la look-up table y del signo, respectivamente.\n.enab_reg_sel_mux1(enab_reg_sel_mux1),\n.enab_reg_sel_mux2(enab_reg_sel_mux2),\n.enab_reg_sel_mux3(enab_reg_sel_mux3)\n);\n\ncounter_d #(.W(iter_bits)) cont_iter\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.load(load_cont_iter),\n.enable(enab_cont_iter),\n.d(d_iter),\n.max_tick(max_tick_iter),\n.min_tick(min_tick_iter),\n.q(cont_iter_out)\n);\n\ncounter_up #(.W(2)) cont_var\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.load(load_cont_var),\n.enable(enab_cont_var),\n.d(d_var),\n.max_tick(max_tick_var),\n.min_tick(min_tick_var),\n.q(cont_var_out)\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\n//Primera Etapa:  Registros que guardan los valores iniciales.\n\nd_ff_en # (.W(1)) reg_operation\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff_RB1), //load signal\n.D(operation), //input signal\n.Q(d_ff1_operation_out) //output signal\n);\n\nd_ff_en # (.W(2)) reg_region_flag\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff_RB1), //load signal\n.D(shift_region_flag), //input signal\n.Q(d_ff1_shift_region_flag_out) //output signal\n);\n\nd_ff_en # (.W(W)) reg_Z0\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff_RB1), //load signal\n.D(data_in), //input signal\n.Q(d_ff1_Z) //output signal\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\n//Segunda Etapa : Registros que guardan el canal elegido para el mux, asi como los mux.\n\nd_ff_en # (.W(1)) reg_ch_mux_1\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_reg_sel_mux1), //load signal\n.D(sel_mux_1), //input signal\n.Q(sel_mux_1_reg) //output signal\n);\n\nMux_2x1 #(.W(W)) mux1_x0\n(\n.select(sel_mux_1_reg),\n.ch_0(x0),\n.ch_1(d_ff_Xn),\n.data_out(first_mux_X)\n);\n\nMux_2x1 #(.W(W)) mux1_y0\n(\n.select(sel_mux_1_reg),\n.ch_0(y0),\n.ch_1(d_ff_Yn),\n.data_out(first_mux_Y)\n);\n\nMux_2x1 #(.W(W)) mux1_z0\n(\n.select(sel_mux_1_reg),\n.ch_0(d_ff1_Z),\n.ch_1(d_ff_Zn),\n.data_out(first_mux_Z)\n);\n\n//----------------------------------------------------------------------------------------------------------------------\n//Tercera Etapa: Registros que guardan los datos provenientes de los mux.\n\nd_ff_en # (.W(W)) reg_val_muxX_2stage\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff2_RB2), //load signal\n.D(first_mux_X), //input signal\n.Q(d_ff2_X) //output signal\n);\n\nd_ff_en # (.W(W)) reg_val_muxY_2stage\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff2_RB2), //load signal\n.D(first_mux_Y), //input signal\n.Q(d_ff2_Y) //output signal\n);\n\nd_ff_en # (.W(W)) reg_val_muxZ_2stage\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff2_RB2), //load signal\n.D(first_mux_Z), //input signal\n.Q(d_ff2_Z) //output signal\n);\n\n//----------------------------------------------------------------------------------------------------------------------\n//Cuarta Etapa : Restadores para el corrimiento del exponente de X y Y, Lookup-Table y mux de signo dependiendo del modo.\n\nSimple_Subt #(.W(EW),.N(iter_bits)) shift_x\n(\n.A(d_ff2_X[W-2:SW]),\n.B(cont_iter_out),\n.Y(sh_exp_x)\n);\n\nSimple_Subt #(.W(EW),.N(iter_bits)) shift_y\n(\n.A(d_ff2_Y[W-2:SW]),\n.B(cont_iter_out),\n.Y(sh_exp_y)\n);\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngenerate\n    case(W)\n    32:\n    begin\n        LUT_ROM_32bits #(.W(W),.N(iter_bits)) LUT32\n        (\n        .address(cont_iter_out),\n        .data_out(data_out_LUT)\n        );\n    end\n    64:\n    begin\n        LUT_ROM_64bits #(.W(W),.N(iter_bits)) LUT64\n        (\n        .address(cont_iter_out),\n        .data_out(data_out_LUT)\n        );\n    end\n    default:\n    begin\n        LUT_ROM_32bits #(.W(W),.N(iter_bits)) LUT32\n        (\n        .address(cont_iter_out),\n        .data_out(data_out_LUT)\n        );\n    end\n    endcase\nendgenerate\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nMux_2x1 #(.W(1)) mux_sign\n(\n.select(mode),\n.ch_0(d_ff2_Z[W-1]),\n.ch_1(d_ff2_Y[W-1]),\n.data_out(sign)\n);\n\n//-------------------------------------------------------------------------------------------------------------------------\n//Quinta Etapa : Registros que guardan los datos provenientes de la etapa anterior.\n\nd_ff_en # (.W(W)) reg_shift_x\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D({d_ff2_X[W-1],sh_exp_x,d_ff2_X[SW-1:0]}), //input signal\n.Q(d_ff3_sh_x_out) //output signal\n);\n\nd_ff_en # (.W(W)) reg_shift_y\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D({d_ff2_Y[W-1],sh_exp_y,d_ff2_Y[SW-1:0]}), //input signal\n.Q(d_ff3_sh_y_out) //output signal\n);\n\nd_ff_en # (.W(W)) reg_LUT\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D(data_out_LUT), //input signal\n.Q(d_ff3_LUT_out) //output signal\n);\n\nd_ff_en # (.W(1)) reg_sign\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D(sign), //input signal\n.Q(d_ff3_sign_out) //output signal\n);\n\n//-------------------------------------------------------------------------------------------------------------------------------------------------------\n//Sexta Etapa : Mux de 3 canales que se activan dependiendo de la variable a calcular.\n\nd_ff_en # (.W(2)) reg_ch_mux_2\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_reg_sel_mux2), //load signal\n.D(sel_mux_2), //input signal\n.Q(sel_mux_2_reg) //output signal\n);\n\nMux_3x1_b #(.W(W)) mux_3x1_var1\n(\n.select(sel_mux_2_reg),\n.ch_0(d_ff2_X),\n.ch_1(d_ff2_Y),\n.ch_2(d_ff2_Z),\n.data_out(add_subt_dataA)\n);\n\nMux_3x1_b #(.W(W)) mux_3x1_var2\n(\n.select(sel_mux_2_reg),\n.ch_0(d_ff3_sh_y_out),\n.ch_1(d_ff3_sh_x_out),\n.ch_2(d_ff3_LUT_out),\n.data_out(add_subt_dataB)\n);\n\nOp_Select   op_select_mod\n(\n.variable(cont_var_out[0]),\n.sign(d_ff3_sign_out),\n.operation(op_add_subt)\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------\n//Septima Etapa : Instanciamiento del módulo de suma y resta.\n\nFPU_Add_Subtract_Function   #(.W(W),.EW(EW),.SW(SW),.SWR(SWR),.EWR(EWR)) add_subt_module\n(   \n.clk(clk),\n.rst(rst),\n.beg_FSM(beg_add_subt),\n.ack_FSM(ack_add_subt),\n.Data_X(add_subt_dataA),\n.Data_Y(add_subt_dataB),\n.add_subt(op_add_subt),\n.r_mode(r_mode),\n.overflow_flag(overflow_flag),\n.underflow_flag(underflow_flag),\n.ready(ready_add_subt),\n.final_result_ieee(result_add_subt)\n);\n\n//-------------------------------------------------------------------------------------------------------------------------------\n//Octava Etapa: Registros que guardan los valores de calculo del modulo de suma y resta.\n\nd_ff_en #(.W(W)) d_ff4_Xn\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff4_Xn),\n.D(result_add_subt),\n.Q(d_ff_Xn)\n);\n\nd_ff_en #(.W(W)) d_ff4_Yn\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff4_Yn),\n.D(result_add_subt),\n.Q(d_ff_Yn)\n);\n\nd_ff_en #(.W(W)) d_ff4_Zn\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff4_Zn),\n.D(result_add_subt),\n.Q(d_ff_Zn)\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------\n//Novena Etapa: Mux de selección del valor de salida, así como el modulo de correccion de signo y los registros intermedios que\n//guardan los datos de salida.\n\nd_ff_en #(.W(1)) reg_ch_mux_3\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_reg_sel_mux3),\n.D(sel_mux_3),\n.Q(sel_mux_3_reg)\n);\n\nMux_2x1 #(.W(W)) mux_2x1_sal\n(\n.select(sel_mux_3_reg),\n.ch_0(d_ff_Xn),\n.ch_1(d_ff_Yn),\n.data_out(mux_sal)\n);\n\nd_ff_en #(.W(W)) d_ff5\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_dff_5),\n.D(mux_sal),\n.Q(data_output2)\n);\n\nsign_inverter #(.W(W)) sign_inverter_mod\n(\n.data(data_output2),\n.shift_region_flag(d_ff1_shift_region_flag_out),\n.operation(d_ff1_operation_out),\n.data_out(sign_inv_out)\n);\n\nd_ff_en #(.W(W)) d_ff5_data_out\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff5_data_out),\n.D(sign_inv_out),\n.Q(data_output)\n);\n\nendmodule\n",
			"file": "/home/jorge/Documents/Karatsuba_FPU/Resultados/CORDIC/CORDIC_Arch3_Vivado/CORDIC_Arch3_Vivado.srcs/sources_1/new/CORDIC_Arch3.v",
			"file_size": 21537,
			"file_write_time": 131195700244670191,
			"settings":
			{
				"buffer_size": 21492,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Hello_Microblaze/Hello_Microblaze.srcs/constrs_1/imports/Karatsuba_FPU/Nexys4_Master.xdc",
			"settings":
			{
				"buffer_size": 37051,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 319.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"isntall",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"Snippet: ",
				"Snippet: forg"
			],
			[
				"package",
				"Package Control: Enable Package"
			]
		],
		"width": 402.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/jorge/Documents/Karatsuba_FPU/Resultados/CORDIC/CORDIC_Arch3_Vivado/CORDIC_Arch3_Vivado.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/CORDIC_Arch2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_multiplication.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/sgn_result.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/bloody_simruns/imports/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Sgf_Multiplication.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/source/rtl/KOA_c_v2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v3.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/RecursiveKOA.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FSM_Mult_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/source/rtl/RecursiveKOA.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/OR_Module.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Round_decoder_M.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/shift_mux.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/fpuuart/FPU_UART.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Mux_3x1.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/MultiplexTxT.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/source/rtl/FPU_Multiplication_Function_v2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/constrs_1/imports/RTL/Nexys4_Master.xdc",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/constrs_1/new/Time_Constrains.xdc",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FPU_Multiplication_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/exp_operation.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Tenth_Phase.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FSM_Add_Subtract.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Priority_Codec_32.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/add_sub_carry_out.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/b_shifter_2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/RegisterAdd.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Multiplexer_AC.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/bloody_simruns/behav/output_log.py",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FSM_input_enable.v",
		"/home/jorge/Documents/Karatsuba_FPU/Proyectos",
		"/home/jorge/Funcionales",
		"/home/jorge/Francis",
		"/home/jorge/Jeffrey/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/CORDIC_Arch2.v",
		"/home/jorge/Jeffrey/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/CORDIC_FSM_v2.v",
		"/home/jorge/Jeffrey/CORDICO/CORDICO.srcs/sources_1/new/CORDIC_Arch3.v",
		"/home/jorge/Jeffrey/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/FPU_Interface_and_NaN/FPU_Interface.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/new/Testbench_Sgf_multiplication.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/sim/testbench_RKOA.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/new/CORDIC_Arch3.v",
		"/home/jorge/Documents/Karatsuba_FPU/Resultados/FPSUB/FPADDFPSUB_Pipelined/FPADDFPSUB_Pipelined.srcs/sources_1/imports/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
		"/home/jorge/Documents/Karatsuba_FPU/Resultados/FPADDFPSUB_Pipelined/FPADDFPSUB_Pipelined.srcs/constrs_1/new/Time_Constrains.xdc",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/vector_simulation_add/imports/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Pipeline_FPADD_sourcefiles/shift_reg.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/shift_reg.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/b_shifter_1.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_double_fpaddsub/imports/TXTVerification_v3/Hexadecimal_A.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/bloody_simruns/imports/behav/Hexadecimal_A.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/constrs_1/imports/RTL/Nexys4_Master.xdc",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/vector_simulation_add/imports/behav/Hexadecimal_B.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/TXTVerification/Hexadecimal_B.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/vector_simulation_add/behav/output_log.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/vector_simulation_add/behav/output_log.py",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/display.log",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Pipeline_FPADD_sourcefiles/shift_reg.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/project_1/archive_project_summary.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Oper_Start_In.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FORMATTER.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/Tenth_Phase_v2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/task_FPADD_FPSUB.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_FUNCIONAL_v1/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Comparators.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/RegisterAdd.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Barrel_shifter.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Mux_Array.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/LZD.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/Shift_left_logical.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/usersnippet_verilogregister.sublime-snippet",
		"/home/jorge/.config/sublime-text-3/Packages/User/usersnippet_verilog.sublime-snippet",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Greater_Comparator.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/RegisterAdd.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/usersnippet_verilogcase3b.sublime-snippet",
		"/home/jorge/.config/sublime-text-3/Packages/User/SublimeLinter.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/User/Distraction Free.sublime-settings",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FSM_Add_Subtract.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Barrel_Shifter_M.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Multiplexer_AC.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/imports/Sim/Sine_Cosine_CORDIC_tb.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/new/Testbench_FPU_Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/LUT_ROM_64bits.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/new/Testbench_LUT.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/LUT_ROM_32bits.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/counter_d.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/new/testbench_CORDICArch2.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/CORDIC_Arch2.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.sim/CORDIC_COS_32bits_round00/behav/CORDIC32_input_angles_dec.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/CORDIC_COS_32bits_round00/imports/COSENO",
		"/home/jorge/TESTING",
		"/home/jorge/FILES/CORDIC32_input_angles_dec.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/LUT_sincos_32.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/imports/ADD_SUB_Files/Hexadecimal_R.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/d_ff_en.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/new/tb_CORDIC_Arch2.v",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Gadget/Verilog Gadget.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Gadget/Default (Linux).sublime-keymap",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Automatic/README.md",
		"/home/jorge/.config/sublime-text-3/Packages/User/Verilog Automatic.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Automatic/Verilog Automatic.sublime-settings",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/source/rtl/KOA_c_v3.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FPU_Multiplication_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Sgf_Multiplication.v",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Automatic/Default (Linux).sublime-keymap",
		"/home/jorge/.config/sublime-text-3/Packages/User/Verilog.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/User/JSON.sublime-settings"
	],
	"find":
	{
		"height": 44.0
	},
	"find_in_files":
	{
		"height": 136.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"rese",
			"resey",
			"rst",
			"PACKAGE_PIN E3",
			"load_cont_var",
			"d_var",
			"enable_Pipeline_input",
			"FSM",
			"SIGN_FLAG_SHT1SHT2",
			"SIGN",
			"Exp_oper_1_EWR",
			"SIGN",
			"raw_Mantissa_SWR1",
			"Array_IN_3",
			"Array_IN_2",
			"fclose",
			"uut",
			"logVectorReference",
			"FPU_PIPELINED_FPADDSUB",
			"SIGN_FLAG_INIT",
			"sign_",
			"sign",
			"%8h",
			"%23h",
			"%26h",
			"%h",
			"\",",
			"\")",
			"\"",
			"\");",
			"FileSaveData",
			"$fwrite(\"",
			"display",
			")\n",
			"add_subt",
			"Shift_reg_FLAGS_7",
			"Shift_reg_FLAGS_6",
			"INPUT_ACTIVE",
			"ready",
			"Shift_reg_FLAGS_6",
			"FLAGS_OR",
			"Shift_reg_FLAGS",
			"LZD_raw_val_EWR",
			"SIGN_FLAG_SHT2",
			"ADD_OVRFLW_FRMT",
			"SIGN_FLAG_SHT1SHT2",
			"enable_input_internal",
			"ack_FSM",
			"beg_FSM",
			";\n",
			"ADD_OVRFLW_NRM",
			"ADD_OVRFLW",
			"Mantissa_M_SWR",
			"raw_Mantissa_SWR",
			"exp_oper_result",
			"LZD_raw_val_EWR",
			"Raw_mant_SGF",
			"Exponent_M_EW",
			"Mantissa_M_SW",
			"real_sign",
			"si",
			"Data_X",
			"add_subt",
			"enable_Pipeline_input",
			"task",
			"raw_Mantissa_SWR1",
			"exp_mux_D1",
			"Mantissa_M_SWR",
			"Mantissa_m_SWR",
			"raw_Mantissa_SWR1",
			"raw_Mantissa_SWR",
			"formatted_number",
			"DMP_EXP_EWSW",
			"intDY_W1",
			"intDX_W1",
			"intDY_W",
			"intDX_W",
			"formatted_number",
			"LZD_raw_output",
			"LZD_raw_output_NRM2",
			"LZD_output_NRM2",
			"Raw_mant_NRM",
			"Add_Subt_LZD",
			"DMP_exp_NRM",
			"DMP_mant_SFG",
			"DmP_mant_SFG",
			"DMP_exp_NRM2",
			"ADDSUB_exp_operand",
			"exp_rslt_NRM2",
			"Exp_oper_1",
			"sftr_odat_SHT2",
			"sftr_idat_SHT2",
			"shift_value_SHT2",
			"DMP_SHT2",
			"Data_array",
			"mux_sel_norm",
			"sftr_odat_SHT1",
			"sftr_idat_SHT1",
			"shft_value_mux_o",
			"Shift_amount_SHT1",
			"DmP_mant_SHT1",
			"DMP_SHT1",
			"b_shifter_one",
			"Shift_amount_EXP",
			"DmP_mant_EXP",
			"DMP_mant_EXP",
			"DmP_exp_EXP",
			"DMP_exp_EXP",
			"DmP_EXP",
			"DMP_EXP",
			"DmP_INIT_W_2",
			"DMP_INIT_W_2",
			"DmP_INIT",
			"DMP_INIT",
			"intDY",
			"intDX",
			"ADD_OVRFLW_FRMT",
			"ADD_OVRFLW_NRM",
			"ADD_OVRFLW_SGF",
			"add_ov",
			"LZD_raw_val_EW",
			"LZD_raw_val_EWR",
			"LZD_raw_val",
			"LZD_raw_output",
			"Exponent_diff",
			"Exponent_m",
			"Exponent_M",
			"Mantissa_m"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"Exp_oper_1_EW",
			"uut",
			"0x%6h",
			"%0x6h",
			"0x%21h",
			"0x%24h",
			"0x%h",
			"\\n\",",
			"\\n\")",
			"\\n\"",
			"\"",
			"\n      $display(\"===============INIT STAGE: input signals============\");\n      $display(\"---------First Operator------------\");\n      $display(\"Mantissa = %23h, Exponent = %8h, sign = %d\", Mantissa1_SW, Exponent1_EW, Sign1);\n      $display(\"Mantissa = %b, Exponent = %b, sign = %b\", Mantissa1_SW, Exponent1_EW, Sign1);\n      $display(\"--------Second Operator------------\");\n      $display(\"Mantissa = %23h, Exponent = %8h, sign = %d\", Mantissa2_SW, Exponent2_EW, Sign2);\n      $display(\"Mantissa = %b, Exponent = %b, sign = %b\", Mantissa2_SW, Exponent2_EW, Sign2);\n",
			"\");",
			"\\n\");",
			"\");",
			"$fwrite(logVectorReference,\"",
			"fwrite",
			"Shift_reg_FLAGS_7",
			"Shift_reg_FLAGS_6",
			"Shift_reg_FLAGS",
			"ADD_OVRFLW_NRM2",
			"ADD_OVRFLW_FRMT",
			"enable_input_internal",
			"//ack_FSM",
			"beg_OP",
			"DMP_INIT_EWSW",
			"intDY_EWSW",
			"intDY_W1",
			"intDX_EWSW",
			"intDX_W1",
			"intDY_W1",
			"intDY_W",
			"intDX_W1",
			"intDX_W",
			"formatted_number_W",
			"formatted_number",
			"LZD_raw_out_EWR",
			"LZD_raw_output",
			"LZD_raw_out_NRM2_EWR",
			"LZD_raw_output_NRM2",
			"LZD_output_NRM2_EW",
			"LZD_output_NRM2",
			"Raw_mant_NRM_SWR",
			"Raw_mant_NRM",
			"wire [SWR-1:0] Raw_mant_NRM;\n",
			"Add_Subt_LZD_SWR",
			"Add_Subt_LZD",
			"DMP_exp_NRM_EW",
			"DMP_exp_NRM",
			"DMP_mant_SFG_SWR",
			"DmP_mant_SFG_SWR",
			"DmP_mant_SFG",
			"DMP_exp_NRM2_EW",
			"DMP_exp_NRM2",
			"ADDSUB_exp_operand_EW",
			"ADDSUB_exp_operand",
			"exp_rslt_NRM2_EW1",
			"exp_rslt_NRM2",
			"Exp_oper_1_EWR",
			"Exp_oper_1",
			"sftr_odat_SHT2_SWR",
			"sftr_odat_SHT2",
			"sftr_idat_SHT2_SWR",
			"sftr_idat_SHT2",
			"shift_value_SHT2_EWR",
			"shift_value_SHT2",
			"DMP_SHT2_EWSW",
			"DMP_SHT2",
			"Data_array_SWR",
			"Data_array",
			"mux_sel_norm_EWR",
			"mux_sel_norm",
			"sftr_odat_SHT1_SWR",
			"sftr_odat_SHT1",
			"sftr_idat_SHT1_SWR",
			"sftr_idat_SHT1",
			"shft_value_mux_o_EWR",
			"shft_value_mux_o",
			"Shift_amount_SHT1_EWR",
			"Shift_amount_SHT1",
			"DmP_mant_SHT1_SW",
			"DmP_mant_SHT1",
			"DMP_SHT1_EWSW",
			"DMP_SHT1",
			"b_shifter_one_SWR",
			"b_shifter_one",
			"Shift_amount_EXP_EW",
			"Shift_amount_EXP",
			"DmP_mant_EXP_SW",
			"DMP_mant_EXP_SW",
			"DMP_mant_EXP",
			"DmP_exp_EXP_EW",
			"DMP_exp_EXP_EW",
			"DMP_exp_EXP",
			"DmP_EXP_EWSW",
			"DmP_EXP",
			"wire [W-2:0] DMP_EXP_EWSW, DmP_EXP;\n",
			"DMP_EXP_EWSW",
			"DMP_EXP",
			"DmP_INIT_EWSW",
			"DMP_EXP_EWSW",
			"DmP_INIT_W_2",
			"DMP_INIT_W_2",
			"DMP_INIT_W.2",
			"DMP_INIT",
			"DMP_INIT_W_2",
			"DMP_INIT",
			"intDY_W",
			"intDX_W",
			"intDX",
			"LZD_raw_val_EWR",
			"LZD_raw_val_EW",
			"Exponent_diff_EW",
			"Exponent_m_EW",
			"Exponent_M_EW",
			"Mantissa_m_SW",
			"Mantissa_M_SW",
			"Mantissa2_SW",
			"Mantissa1_SW",
			"Operand2_W",
			"Operand1_W",
			"Exponent2_EW",
			"Exponent1_EW",
			"raw_Mantissa_SWR",
			"shft_value_mux_o",
			";",
			"EW",
			"UNDRFLW_FLAG_FRMT"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Resultados/CORDIC/CORDIC_Arch3_Vivado/CORDIC_Arch3_Vivado.srcs/sources_1/new/CORDIC_Arch3.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21492,
						"regions":
						{
						},
						"selection":
						[
							[
								19641,
								19641
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6231.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/home/jorge/Documents/Hello_Microblaze/Hello_Microblaze.srcs/constrs_1/imports/Karatsuba_FPU/Nexys4_Master.xdc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 37051,
						"regions":
						{
						},
						"selection":
						[
							[
								9883,
								9883
							]
						],
						"settings":
						{
							"syntax": "Packages/TCL/Tcl.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 2768.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 48.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 116.0
	},
	"pinned_build_system": "",
	"project": "",
	"replace":
	{
		"height": 40.0
	},
	"save_all_on_build": false,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 322.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"Add_Subt"
			]
		],
		"width": 314.0
	},
	"selected_group": 0,
	"settings":
	{
		"last_automatic_layout":
		[
			[
				0,
				0,
				1,
				1
			]
		]
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 39.0,
	"status_bar_visible": true,
	"template_settings":
	{
		"max_columns": 2
	}
}
