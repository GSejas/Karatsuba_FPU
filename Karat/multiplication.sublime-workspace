{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"NRM",
				"NRM_STAGE"
			],
			[
				"over",
				"overflow"
			],
			[
				"ARR",
				"Array_IN_3"
			],
			[
				"Ope",
				"Operand1_W"
			],
			[
				"Da",
				"Data_X"
			],
			[
				"log",
				"logVectorReference"
			],
			[
				"beg",
				"begin\tbegin"
			],
			[
				"ena",
				"enable_Pipeline_input"
			],
			[
				"SGF",
				"SFG_ACTIVE"
			],
			[
				"SHT2",
				"SHT2_ACTIVE"
			],
			[
				"SHT",
				"SHT1_ACTIVE"
			],
			[
				"EXP",
				"EXP_ACTIVE"
			],
			[
				"Theoretical_result_",
				"Theoretical_result_exponent"
			],
			[
				"un",
				"underflow_flag_t"
			],
			[
				"L",
				"L_limit"
			],
			[
				"under",
				"underflow_flag"
			],
			[
				"Sign",
				"Sign1"
			],
			[
				"Ex",
				"Exponent1_EW"
			],
			[
				"dia",
				"display"
			],
			[
				"be",
				"begin\tbegin"
			],
			[
				"M",
				"Mantissa_M"
			],
			[
				"re",
				"reg"
			],
			[
				"SW",
				"SW-1"
			],
			[
				"zero",
				"zero_flag"
			],
			[
				"ZERO",
				"ZERO_FLAG_SHT2"
			],
			[
				"reg",
				"register\t: w bit d register "
			],
			[
				"Comp",
				"Comparator_Less"
			],
			[
				"SWR",
				"SWR-1"
			],
			[
				"Compara",
				"Comparators"
			],
			[
				"Mul",
				"MultiplexTxT"
			],
			[
				"in",
				"include"
			],
			[
				"W",
				"W-2"
			],
			[
				"DMP_exp",
				"DMP_exp_NRM2"
			],
			[
				"EW",
				"EW-1"
			],
			[
				"EWR",
				"EWR-1"
			],
			[
				"LZ",
				"LZD_output"
			],
			[
				"fi",
				"final_result_ieee_o"
			],
			[
				"mux",
				"mux_sel_norm"
			],
			[
				"LZD",
				"LZD_output"
			],
			[
				"ADD",
				"ADD_OVRFLW_SGF"
			],
			[
				"INPUT",
				"INPUT_ACTIVE"
			],
			[
				"d_ff3",
				"d_ff3_LUT_out"
			],
			[
				"d_ff2",
				"d_ff2_Z"
			],
			[
				"para",
				"parameter"
			],
			[
				"rea",
				"ready_cordic"
			],
			[
				"CO",
				"CORDIC_Arch2"
			],
			[
				"al",
				"always\talways"
			]
		]
	},
	"buffers":
	[
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_multiplication.v",
			"settings":
			{
				"buffer_size": 4541,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/rtl/FPU_Multiplication_Function_v2.v",
			"settings":
			{
				"buffer_size": 8447,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/constrs_1/imports/RTL/Nexys4_Master.xdc",
			"settings":
			{
				"buffer_size": 37288,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/constrs_1/new/Time_Constrains.xdc",
			"settings":
			{
				"buffer_size": 2594,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FPU_Multiplication_Function.v",
			"settings":
			{
				"buffer_size": 8367,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
			"settings":
			{
				"buffer_size": 12654,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/exp_operation.v",
			"settings":
			{
				"buffer_size": 2050,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Tenth_Phase.v",
			"settings":
			{
				"buffer_size": 2485,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "`timescale 1ns / 1ps\n//////////////////////////////////////////////////////////////////////////////////\n// Company: \n// Engineer: \n// \n// Create Date:    21:09:39 08/25/2015 \n// Design Name: \n// Module Name:    FSM_Add_Subtract \n// Project Name: \n// Target Devices: \n// Tool versions: \n// Description: \n//\n// Dependencies: \n//\n// Revision: \n// Revision 0.01 - File Created\n// Additional Comments: \n//\n//////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\nmodule FSM_Add_Subtract\n\t(\n\t\t//INPUTS\n\t\tinput wire clk, //system clock\n\t\tinput wire rst, //system reset\n\t\tinput wire rst_FSM,\n\t\tinput wire beg_FSM, //Begin Finite State Machine\n\t\t//**REVISAD\n\t\t\n\t//////////////////////////////////////////////////////////////////////////////\n\t\t//Oper_Start_In evaluation signals\n\t\tinput wire zero_flag_i,\n\t\t\n\t\t//Exp_operation evaluation signals\n\t\tinput wire norm_iteration_i,\n\t\t\n\t\t//Barrel_Shifter evaluation signals\n\t\t//None\n\n\t\t//Add_Subt_Sgf evaluation signals\n\t\tinput wire add_overflow_i,\n\n\t\t//LZA evaluation signals\n\t\t//None\n\n\t\t//Deco_round evaluation Signals\n\t\tinput wire round_i,\n\n\t\t//Final_result evaluation signals\n\t\t//None\n\t\t\n\t\t\n\t\t//OUTPUT SIGNALS\n\t\n////////////////////////////////////////////////////////////////////////////////////\t\n\t\t//Oper_Start_In control signals\n\t\toutput wire load_1_o,//Enable input registers\n\t\toutput wire load_2_o,//Enable output registers\n\n\t\t//Exp_operation control signals\n\t\toutput reg load_3_o, //Enable Output registers\n\t\toutput reg load_8_o,\n\t\toutput reg A_S_op_o, //Select operation for exponent normalization(Subt for left shift, Add for right shift)\n\t\n\t\t\n\t\t//Barrel shifter control signals\n\t\toutput reg load_4_o, //Enable Output registers\n\t\toutput reg left_right_o, //Select direction shift (right=0, left=1)\n\t\toutput reg bit_shift_o, //bit input for shifts fills\n\n\t\t\n\t\t//Add_Subt_sgf control signals\n\t\toutput reg load_5_o, //Enables Output registers\n\t\n\t\t\n\t\t//LZA control signals\n\t\toutput reg load_6_o, //Enables Output registers\n\n\t\t//Deco_Round control signals\n\t\t//None\n\n\t\t//Final_Result control signals\n\t\toutput reg load_7_o,\n\t\t\n\t\t///////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t\t//Multiplexer selector for Exp_operation's OPER_A\n\n\t\toutput reg ctrl_a_o,\n\n\t\t//Multiplexer selector for Exp_operation's OPER_B & Barrel_Shifter's Shift value\n\n\t\toutput reg [1:0] ctrl_b_o,\n\t\toutput reg ctrl_b_load_o,\n\n\t\t//Multiplexer selector for Data shift\n\n\t\toutput reg ctrl_c_o,\n\n\t\t//Multiplexer selector for Add_Subt_Sgf's inputs\n\n\t\toutput reg ctrl_d_o,\n\n\t\t\n\n\t\t\n\t\t\n\t\t//Internal reset signal\n\t\toutput reg rst_int,\n\t\t//Ready  Signal\n\t\toutput reg ready\n\t );\n\n\nlocalparam [3:0] \n//First I'm going to declarate the registers of the first phase of execution\n\t\t\t\t\t start = 4'd0, //This state evaluates the beg_FSM to begin operations\n\n\t\t\t\t     load_oper = 4'd1, //This state enables the registers that contains\n\t\t\t\t\t\t\t\t\t\t\t //both operands and the operator\n\t\t\t\t\t zero_info_state = 4'd2, //Evaluate zero condition\n\n\t\t\t\t\t load_diff_exp = 4'd3, //Enable registers for the exponent on the small value normalization and for the first\n\t\t\t\t\t \t\t\t\t\t\t//result normalization\n\t\t\t\t\t \t\t\t\t\t\t\n\t\t\t\t\t extra1_64= 4'd4,\t\t\t\t\t\n\t\t\t\t\t \n\t\t\t\t\t norm_sgf_first= 4'd5, //Enable the barrel shifter's registers and evaluate if it's the first time (small operand) or the\n\t\t\t\t\t \t\t\t\t\t  //second time (result normalization)\t\n                      \n\t\t\t\t\t add_subt = 4'd6, //Enable the add_subt_sgf's registers  \n\n\t\t\t\t\t add_subt_r = 4'd7, //Enable the add_subt_sgf's registers for round condition\n\t\t\t\t\t \n\t\t\t\t\t overflow_add = 4'd8,\n\t\t\t\t\t \n\t\t\t\t\t round_sgf = 4'd9, //Evaluate the significand round condition\n                                          \n                      overflow_add_r = 4'd10,\n     \n                      extra2_64= 4'd11, //Enable registers for the exponent normalization on round condition\n                                                                \n                      norm_sgf_r = 4'd12, //Enable the barrel shifter's registers for round condition\n \n                      load_final_result  = 4'd13, //Load the final_result's register with the result\n \n                      ready_flag = 4'd14; //Enable the ready flag with the final result\n\n                     \n                     \n\t\t\t\t\t \n\t\t\t\t\t \n\n\n\t\t\t\t\t \n\t\t\t\t\t//**********************REVISADO\n\t\n\t\t\t\t\t\nreg [3:0] state_reg, state_next ; //state registers declaration\n\t\t \n////////////////////////Logic outputs///////////////77\n\nassign load_1_o= (state_reg==load_oper);\nassign load_2_o= (state_reg==zero_info_state);\n\n////\nalways @(posedge clk, posedge rst)\n\tif (rst) begin\n\t\tstate_reg <= start;\t\n\tend\n\telse begin\n\t\tstate_reg <= state_next;\n\tend\n\n///\t\nalways @*\n\tbegin\n\tstate_next = state_reg;\n\trst_int = 0;\n\t\t//Oper_Start_In control signals\n\t//load_1_o=0;\n\t//load_2_o=0;\n\n\t//Exp_operation control signals\n\tload_3_o=0;\n\tload_8_o=0;\n\tA_S_op_o=1;\n\n\t//Barrel shifter control signals\n\tload_4_o=0;\n\tleft_right_o=0;\n\tbit_shift_o=0; //bit input for shifts fills\n\n\t\n\t//Add_Subt_sgf control signals\n\tload_5_o=0;\n\n\t//LZA control signals\n\tload_6_o=0;\n\n\t//Deco_Round control signals\n\t//None\n\n\t//Final_Result control signals\n\tload_7_o=0;\n\t\n\t///////////////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n\t//Multiplexer selector for Exp_operation's OPER_A\n\t\n\tctrl_a_o=0;\n\n\t//Multiplexer selector for Exp_operation's OPER_B\n\n\tctrl_b_o=2'b00;\n\tctrl_b_load_o=0;\n\n\t//Multiplexer selector for Barrel_Shifter's Data shift\n\n\tctrl_c_o=0;\n\n\t//Multiplexer selector for Barrel_Shifter's Shift value\n\n\n\t//Multiplexer selector for Add_Subt_Sgf's inputs\n\n\tctrl_d_o=0;\n\n\t\n\t//Ready Phase\n\tready = 0;\n\t//**REVISADO\n\trst_int = 0;\n\t\n\tcase(state_reg)\n//FPU reset \n\t\tstart: begin\n\t\t\trst_int=1;\n\n\t\t\tif(beg_FSM) begin\n\t\t\t\tstate_next = load_oper;\n\t\t\tend\n\t\tend\n\n\t\tload_oper: //Load input registers for  Oper_star in evaluation\n\t\t\n\t\tbegin\n\t\t\t\n\t\t//\tload_1_o = 1;\n\t\t\tstate_next = zero_info_state;\n\t\tend\n\n\t\tzero_info_state: //In case of zero condition, go to final result for ready flag. Else, continue with the calculation\n\t\tbegin\n\t\t\tif (zero_flag_i)begin\n\t\t\t\tstate_next = ready_flag;end\n\t\t\telse begin\n\t\t\t\t//load_2_o = 1;\n\t\t\t\tstate_next = load_diff_exp;end\n\t\tend\n\t\t\n\n\t\tload_diff_exp: //in first instance, Calculate DMP - DmP exponents, in other iteration, evaluation in\n\t\tbegin\n\t\t\tload_3_o = 1;\n\t\t\t/*\n\t\t\tif ()*/\n\n\t\t\tstate_next = extra1_64;\n\t\tend\n\n        extra1_64:\n        begin\n        load_3_o = 1;\n            if (norm_iteration_i)begin\n                load_8_o=1;\n                if(add_overflow_i)begin\n                    A_S_op_o=0;\n                    left_right_o=0;\n                    bit_shift_o=1;\n                end\n                        \n\t            else begin\n\t                A_S_op_o=1;\n\t                left_right_o=1;\n\t                bit_shift_o=0;\n                end\n            end               \n            state_next = norm_sgf_first;\n        end\n        \n\t\tnorm_sgf_first: //\n\t\tbegin\n\t\t\tload_4_o = 1;\n\t\t\tif (norm_iteration_i)begin\n\t\t\t\tif(add_overflow_i)begin\n                    left_right_o=0;\n                    bit_shift_o=1;\n                    state_next = round_sgf;\n                end\n\t\t\t\telse begin\n\t\t\t\t\tleft_right_o=1;\n\t\t\t\t\tbit_shift_o=0;\n\t\t\t\t\tstate_next = round_sgf;end\n\t\t\tend\n\t\t\telse \n\t\t\t\tstate_next = add_subt;\n\t\tend\n\n\n\t\tadd_subt:\n\t\tbegin\n\t\t\t//Reg enables\n\t\t\tload_5_o = 1;\n\t\t\tctrl_c_o = 1;\n\t\t\tstate_next = overflow_add;\n\t\tend\n\n\t\toverflow_add:\n\t\tbegin\n\t\t\t//Reg enables/Disables\n\t\t\tload_6_o=1;\n\t\t\tctrl_b_load_o=1;\n            if ( add_overflow_i)begin\n                ctrl_b_o=2'b10;\n                \n                end\n            else begin\n                A_S_op_o=1;\n                ctrl_b_o=2'b01;\n                \n\n            end\t\n            //state_next = load_exp_oper_over;\n            state_next = extra1_64;\n\t\tend\n\n\n\n\t\tround_sgf:\n\t\tbegin\n\t\t\tload_4_o = 0;\n\t\t\t\n\t\t\t\tif(round_i) begin\n\t\t\t\t\tctrl_d_o =1;\n\t\t\t\t\tctrl_a_o = 1;\n\t\t\t\t\tstate_next = add_subt_r; end\n\t\t\t\telse begin\n\t\t\t\t\tstate_next = load_final_result; end\n\t\tend\n\n\t\t\n\t\tadd_subt_r:\n\t\tbegin\n\t\t\tload_5_o = 1;\n\t\t\tstate_next = overflow_add_r;\n\t\t\t\n\t\tend\n\t\t\n\t\toverflow_add_r:\n\t\tbegin\n            ctrl_b_load_o=1;\t\n\t\t\tif ( add_overflow_i)begin\n                ctrl_b_o=2'b10;\n                end\n            else begin\n                ctrl_b_o=2'b11;\n                end\t\t\n\t\t    state_next = extra2_64;\n\t\tend\n\t\t\n\n\t\textra2_64:\n\t\t\n\t\tbegin\n  \t\t\tload_3_o = 1;\n            load_8_o = 1;\n\t\t\tif ( add_overflow_i)begin\n                A_S_op_o=0;\n\t            bit_shift_o=1;\n            end\n\t\n\t\t\tstate_next = norm_sgf_r;\n\t\t  \n        end\n      \n\t\tnorm_sgf_r:\n\t\tbegin\n\t\t\tload_4_o = 1;\n\t\t\tif ( add_overflow_i)begin\n                left_right_o=0;\n                bit_shift_o=1;\n            end\n\t\t\tstate_next = load_final_result;\n\t\tend\n\t\t\n\t\tload_final_result:\n\t\tbegin\n\t\t\tload_7_o = 1;\n\t\t\tstate_next = ready_flag;\n\t\tend\n\t\tready_flag:\n\t\tbegin\n\t\t\tready = 1;\n\t\t\t\tif(rst_FSM) begin\n\t\t\t\t\tstate_next = start;end\n\t\tend\n\n\t\tdefault:\n\t\tbegin\n\t\t\tstate_next =start;end\n\tendcase\nend\n\n\t\nendmodule\t\n",
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FSM_Add_Subtract.v",
			"file_size": 8934,
			"file_write_time": 131183957446629510,
			"settings":
			{
				"buffer_size": 8944,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
			"settings":
			{
				"buffer_size": 12627,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Priority_Codec_32.v",
			"settings":
			{
				"buffer_size": 2322,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Add_Subt.v",
			"settings":
			{
				"buffer_size": 2538,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/add_sub_carry_out.v",
			"settings":
			{
				"buffer_size": 815,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "`timescale 1ns / 1ps\n//////////////////////////////////////////////////////////////////////////////////\n// Company: \n// Engineer: \n// \n// Create Date: 03/12/2016 06:18:20 PM\n// Design Name: \n// Module Name: Mux_Array\n// Project Name: \n// Target Devices: \n// Tool Versions: \n// Description: \n// \n// Dependencies: \n// \n// Revision:\n// Revision 0.01 - File Created\n// Additional Comments:\n// \n//////////////////////////////////////////////////////////////////////////////////\n\n\nmodule Mux_Array\n    #(parameter SWR=26, parameter EWR=5)\n    (\n    input wire [EWR-1:0] Shift_Value_i,\n    input wire [SWR-1:0] Shift_Data_i,\n    input wire Left_Right_i,\n    input wire Bit_Shift_i,\n    /////////////////////////////////////////////7\n    output wire [SWR-1:0] sht_result\n    );\n////\nwire [SWR-1:0] Data_array[EWR+1:0];\n\n//////////////////7\ngenvar k;//Level\n///////////////////77777\nRotate_Mux_Array #(.SWR(SWR)) first_rotate(\n\t.Data_i(Data_i),\n\t.select_i(FSM_left_right_i),\n\t.Data_o(Data_array [0][SWR-1:0])\n\t);\ngenerate for (k=0; k < 3; k=k+1) begin\n\tshift_mux_array #(.SWR(SWR), .LEVEL(k)) shift_mux_array(\n\t\t.Data_i(Data_array[k]),\n\t\t.select_i(Shift_Value_i[k]),\n\t\t.bit_shift_i(bit_shift_i),\n\t\t.Data_o(Data_array[k+1])\n\t\t);\n\tend\nendgenerate\n\nRegisterAdd #(.W(SWR)) Mid_Reg(\n        .clk(clk),\n        .rst(rst),\n        .load(1'b1),\n        .D(Data_array[3]),\n        .Q(Data_array[4])\n        );\n\ngenerate for (k=3; k < EWR; k=k+1) begin\n\tshift_mux_array #(.SWR(SWR), .LEVEL(k)) shift_mux_array(\n\t\t.Data_i(Data_array[k+1]),\n\t\t.select_i(Shift_Value_i[k]),\n\t\t.bit_shift_i(bit_shift_i),\n\t\t.Data_o(Data_array[k+2])\n\t\t);\n\tend\nendgenerate\n\nRotate_Mux_Array #(.SWR(SWR)) last_rotate(\n\t.Data_i(Data_array[EWR+1]),\n\t.select_i(FSM_left_right_i),\n\t.Data_o(Data_o)\n\t);\n\t\n\n\t\nendmodule\n",
			"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/b_shifter_2.v",
			"file_size": 1774,
			"file_write_time": 131189172842516620,
			"settings":
			{
				"buffer_size": 1768,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/RegisterAdd.v",
			"settings":
			{
				"buffer_size": 818,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/MultiplexTxT.v",
			"settings":
			{
				"buffer_size": 994,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Mux_3x1.v",
			"settings":
			{
				"buffer_size": 799,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/fpuuart/FPU_UART.v",
			"settings":
			{
				"buffer_size": 4370,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/shift_mux.v",
			"settings":
			{
				"buffer_size": 1224,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Round_decoder_M.v",
			"settings":
			{
				"buffer_size": 980,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/OR_Module.v",
			"settings":
			{
				"buffer_size": 856,
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/rtl/RecursiveKOA.v",
			"settings":
			{
				"buffer_size": 2468,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FSM_Mult_Function.v",
			"settings":
			{
				"buffer_size": 5817,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/RecursiveKOA.v",
			"settings":
			{
				"buffer_size": 2461,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v3.v",
			"settings":
			{
				"buffer_size": 6790,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "source/rtl/KOA_c_v2.v",
			"settings":
			{
				"buffer_size": 9722,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v2.v",
			"settings":
			{
				"buffer_size": 9722,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Sgf_Multiplication.v",
			"settings":
			{
				"buffer_size": 10589,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/new/Testbench_Sgf_multiplication.v",
			"settings":
			{
				"buffer_size": 1836,
				"line_ending": "Unix"
			}
		},
		{
			"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/sim/testbench_RKOA.v",
			"settings":
			{
				"buffer_size": 3845,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Multiplexer_AC.v",
			"settings":
			{
				"buffer_size": 754,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FSM_input_enable.v",
			"settings":
			{
				"buffer_size": 3019,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/bloody_simruns/imports/behav/Hexadecimal_A.txt",
			"settings":
			{
				"buffer_size": 9216,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/bloody_simruns/imports/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
			"settings":
			{
				"buffer_size": 34676,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/bloody_simruns/behav/output_log.py",
			"settings":
			{
				"buffer_size": 9534,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
			"settings":
			{
				"buffer_size": 24169,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "//==================================================================================================\n//  Filename      : CORDIC_Arch3.v\n//  Created On    : 2016-09-17 18:42:38\n//  Last Modified : 2016-09-18 15:24:49\n//  Revision      : \n//  Author        : Jorge Sequeira Rojas\n//  Company       : Instituto Tecnologico de Costa Rica\n//  Email         : jsequeira@gmail.com\n//\n//  Description   : \n//   Changelog> The adder structure will be optimized for the CORDIC algorithm. \n//\t\t\t\trounding will be set to 2b'00. FPU Adder structure usage will be \n//\t\t\t\tamplified to 3 units.\n//\n//\n//==================================================================================================\n`timescale 1ns / 1ps\n\n\nmodule CORDIC_Arch3 #(parameter W = 32, parameter EW = 8, parameter SW = 23, parameter SWR=26, parameter EWR = 5)//*/\n/*#(parameter W = 64, parameter EW = 11, parameter SW = 52, parameter SWR = 55, parameter EWR = 6) //-- Double Precision */\n(\n//Input Signals\ninput wire clk,                         //\tReloj del sistema.\ninput wire rst,                         //\tSeñal de reset del sistema.\ninput wire beg_fsm_cordic,              //\tSeñal de inicio de la maquina de estados del módulo CORDIC.\ninput wire ack_cordic,                  //\tSeñal de acknowledge proveniente de otro módulo que indica que ha recibido el resultado del modulo CORDIC.\ninput wire operation,\t\t\t\t\t//\tSeñal que indica si se realiza la operacion seno(1'b1) o coseno(1'b0).\n\ninput wire [W-1:0] data_in,             //\tDato de entrada, contiene el angulo que se desea calcular en radianes.\ninput wire [1:0] shift_region_flag,     //\tSeñal que indica si el ángulo a calcular esta fuera del rango de calculo del algoritmo CORDIC.\n\n//Output Signals\noutput wire ready_cordic,                //\tSeñal de salida que indica que se ha completado el calculo del seno/coseno.\noutput wire overflow_flag,                  //\tBandera de overflow de la operacion.\noutput wire underflow_flag,\t\t\t\t\t//\tBandera de underflow de la operacion.\noutput wire [W-1:0] data_output          //\tBus de datos con el valor final del angulo calculado.\n);\n\nlocalparam d_var = 0;\t\t\t\t       //\tValor por defecto que se le carga al contador de variables.\nlocalparam d_iter = 0;                  //\tValor por defecto que se le carga al contador de iteraciones.\nlocalparam mode = 1'b0;\nlocalparam r_mode = 2'b00;\nlocalparam iter_bits = 4;                  //Modificar valor para obtener diferente cantidad de iteraciones; ejem= 3=8iter, 4=16iter. etc\n\nwire [W-1:0] x0,y0;\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngenerate\n    case(W)\n    \n    32:\n    begin\n        assign x0 = 32'h3f1b74ee; \t\t\t      //\tx0 = 0.607252935008881, valor inicial de la variable X.\n        assign y0 = 32'h00000000; \t\t\t      //\ty0 = 0, valor inicial de la variable Y.\n    end\n    \n    64:\n    begin\n        assign x0 = 64'h3fe36e9db5086bc9;\t     //\tx0 = 0.607252935008881, valor inicial de la variable X.\n        assign y0 = 64'h0000000000000000;\t     //\ty0 = 0, valor inicial de la variable Y.\n    end\n    \n    default:\n    begin\n        assign x0 = 32'h3f1b74ee;                   //    x0 = 0.607252935008881, valor inicial de la variable X.\n        assign y0 = 32'h00000000;                   //    y0 = 0, valor inicial de la variable Y.\n    end    \n    endcase\nendgenerate\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n//Signal declaration\n\nwire reset_reg_cordic;\n\n//ENABLE\nwire enab_d_ff_RB1;                                    \t    // \tEnable de la primera linea de registros.\nwire enab_d_ff2_RB2;                                    \t// \tEnable de la segunda linea de registros.\nwire enab_RB3;\t\t\t\t\t\t\t\t\t\t\t\t//\tEnable del registro que guarda el valor del signo, dependiendo del modo del algoritmo.\nwire enab_d_ff4_Xn, enab_d_ff4_Yn, enab_d_ff4_Zn;       \t//\tEnable de los registros que guardan los datos provenientes del modulo de suma/resta.\nwire enab_d_ff5_data_out;\t\t\t\t\t\t\t\t\t//\tEnable del registo que guarda el valor de salida final, listo para enviarse al procesador.\nwire enab_cont_iter, enab_cont_var;                     \t//\tEnable de los contadores de variable e iteracion\nwire load_cont_iter, load_cont_var;                      \t//\tSeñal de carga de un valor en los contadores de variable e iteraciones.\nwire enab_dff_5;\n\n\n\n//SELECTION\nwire sel_mux_1, sel_mux_3;                                  //\tSeñales de seleccion provenientes de la maquina de estados.\nwire [1:0] sel_mux_2;                      \t\t\t\t\t//\tSeñal de seleccion que se activa dependiendo de la variable que se este calculando.\n\nwire sel_mux_1_reg, sel_mux_3_reg;                          //\tSeñales de seleccion provenientes de la maquina de estados.\nwire [1:0] sel_mux_2_reg;                      \t\t\t\t//\tSeñal de seleccion que se activa dependiendo de la variable que se este calculando.\n\n//DATA WIRES\nwire d_ff1_operation_out;\t\t\t\t\t\t\t\t\t//\tSalida del registro que guarda el dato de entrada de la operacion a realizar, coseno(1'b0) o seno(1'b1)\nwire [1:0] d_ff1_shift_region_flag_out;                    \t//\tSalida del registro que guarda el dato de entrada que indica si el ángulo a calcular esta fuera del rango de calculo del algoritmo CORDIC.\nwire [W-1:0] d_ff1_Z;                                    \t//\tSalidas de los registros que guardan los valores iniciales de las variables X, Y y Z.\nwire [W-1:0] d_ff_Xn, d_ff_Yn, d_ff_Zn;\t\t\t\t\t\t//\tSalidas de los registros que guardan los valores de las variables X, Y y Z despues de cada iteracion.\nwire [W-1:0] first_mux_X, first_mux_Y, first_mux_Z;     \t//\tSalidas de los mux que escogen entre un valor inicial y el valor obtenido en una iteracion.\nwire [W-1:0] d_ff2_X, d_ff2_Y, d_ff2_Z;                 \t//\tSalidas de los registros que guardan los valores provenientes de la primera linea de mux.\nwire sign;                                              \t//\tSalida del mux que escoge entre el signo de Y o Z, dependiendo del modo, ya sea rotacion o vectorizacion.\nwire [W-1:0] data_out_LUT;\t\t\t\t\t\t\t\t\t//\tSalida del modulo generate que genera la LUT necesaria dependiendo del ancho de palabra.\nwire [iter_bits-1:0] cont_iter_out;                         //\tSalida del contador que cuenta las iteraciones realizadas.\nwire [EW-1:0] sh_exp_x, sh_exp_y;                        \t//\tSalidas de los sumadores de punto fijo que realizan los desplazamientos.\nwire [W-1:0] d_ff3_sh_x_out, d_ff3_sh_y_out;            \t//\tSalida del registro que guarda el valor de X y Y luego de realizar los desplazamientos.\nwire [W-1:0] d_ff3_LUT_out;                             \t//\tSalida del registro que guarda el valor de la LUT.\nwire d_ff3_sign_out;                                    \t//\tSalida del registro que guarda el valor del signo.\nwire [1:0] cont_var_out;                                \t//\tSalida del contador que cuenta las variables calculadas.\nwire [W-1:0] mux_sal;\t\t\t\t                     \t//\tSalida del mux final para colocar en la salida el valor deseado.\nwire [W-1:0] data_output2; \t\t\t\t\t\t\t\t\t//\tSalida del registro antes del cambio de signo.\nwire [W-1:0] sign_inv_out;\t\t\t\t\t                //\tSalida del modulo de inversion de signo, dependiendo de si se el angulo de entrada estaba fuera del rango de calculo del algoritmo CORDIC.\nwire min_tick_iter,max_tick_iter;                       \t//\tSeñales que indican cuando se ha alcanzado el valor mas bajo y masalto de cuenta, correspondientemente en el contador de iteraciones.\nwire min_tick_var,max_tick_var;                         \t//\tSeñales que indican cuando se ha alcanzado el valor mas bajo y masalto de cuenta, correspondientemente en el contador de variables.\nwire enab_reg_sel_mux1,enab_reg_sel_mux2,enab_reg_sel_mux3;\nwire ready_add_subt;              \t\t\t\t\t\t\t//\tSeñal que indica que se ha realizado la operacion de suma/resta en punto flotante.\nwire [W-1:0] result_add_subt;     \t\t\t\t\t\t\t//\tDato de entrada, contiene el resultado del módulo de suma/resta.\nwire beg_add_subt;                \t\t\t\t\t\t\t//\tSeñal de salida que indica que se debe de iniciar el modulo de suma/resta.\nwire ack_add_subt;                \t\t\t\t\t\t\t//\tSeñal que le indica al modulo de suma/resta que se recibio el resultado de este modulo correctamente.\nwire op_add_subt;                 \t\t\t\t\t\t\t//\tSeñal hacia el módulo de suma/resta que indica si se va a realizar una suma(1'b0) o una resta(1'b1).\nwire [W-1:0] add_subt_dataA;      \t\t\t\t\t\t\t//\tBus de datos hacia el modulo de suma/resta con el valor al que se le desea aplicar dicha operacion.\nwire [W-1:0] add_subt_dataB;      \t\t\t\t\t\t\t//\tBus de datos hacia el modulo de suma/resta con el valor al que se le desea aplicar dicha operacion.\n\n//Instanciación\n//------------------------------------------------------------------------------------------------------------------------\n//FSM\n\nCORDIC_FSM_v2 cordic_FSM\n(\n.clk(clk),\t\t\t\t\t\t\t\t\t\t\t//\tReloj del sitema.\n.reset(rst),\t\t\t\t\t\t\t\t\t\t//\tReset del sitema.\n.beg_FSM_CORDIC(beg_fsm_cordic),\t\t\t\t\t\t\t\t//\tSeñal de inicio de la maquina de estados.\n.ACK_FSM_CORDIC(ack_cordic),\t\t\t\t\t\t\t\t//\tSeñal proveniente del modulo que recibe el resultado, indicado que el dato ha sido recibido.\n.operation(d_ff1_operation_out),\t\t\t\t\t\t\t\t\t//\tSeñal que determina si lo que se requiere es realizar un coseno(1´b0) o seno (1'b1).\n.exception(1'b0),\n.shift_region_flag(d_ff1_shift_region_flag_out),\t\t\t\t\t\t//\tSeñal que indica si el angulo a calcular se encuentra fuera del rango de calculo del algoritmo CORDIC.\n.cont_var(cont_var_out),\t\t\t\t\t\t\t\t//\tSeñal que indica cual varible se va a calcular. Proveniente del contador de variables.\n.ready_add_subt(ready_add_subt),\t\t\t\t\t\t\t\t//\tSeñal proveniente del módulo de suma/resta, indica que se ha terminado la operacion y que se puede disponer del resultado de dicho modulo.\n.max_tick_iter(max_tick_iter), \n.min_tick_iter(min_tick_iter),\t\t\t\t//\tSeñales que indican la maxima y minima cuenta, respectivamente, en el contador de iteraciones.\n.max_tick_var(max_tick_var),\n.min_tick_var(min_tick_var),\t\t\t\t\t//\tSeñales que indican la maxima y minima cuenta, respectivamente, en el contador de variables.\n\n//Output Signals\n.reset_reg_cordic(reset_reg_cordic),\n.ready_CORDIC(ready_cordic),\t\t\t\t\t\t\t\t//\tSeñal que indica que el calculo CORDIC se ha terminado.\n.beg_add_subt(beg_add_subt),\t\t\t\t\t\t\t\t//\tSeñal que indica al modulo de suma/resta que inicie su operacion.\n.ack_add_subt(ack_add_subt),\t\t\t\t\t\t\t\t//\tSeñal que le indica al modulo de suma/resta que se ha recibido exitosamente el resultado que este entrega.\n.sel_mux_1(sel_mux_1),\n.sel_mux_3(sel_mux_3),\t\t\t\t\t\t//\tSeñales de seleccion de mux, la primera escoge el canal 0 si es la primera iteracion, en otro caso escoge el canal 1, y la segunda escoge cual variable (X o Y) debe aparecer a la salida.\n.sel_mux_2(sel_mux_2),\t\t\t\t\t\t\t\t//\tSeñal de seleccion de mux, que escoge entre X, Y o Z dependiendo de cual variable se deba calcular en ese momento.\n.enab_cont_iter(enab_cont_iter),\n.load_cont_iter(load_cont_iter),\t\t\t\t//\tSeñales de habilitacion y carga, respectivamente, en el contador de iteraciones.\n.enab_cont_var(enab_cont_var),\n.load_cont_var(load_cont_var),\t\t\t\t//\tSeñales de habilitacion y carga, respectivamente, en el contador de variables.\n.enab_RB1(enab_d_ff_RB1),\n.enab_RB2(enab_d_ff2_RB2),\t\t\t\t\t\t\t//\tSeñales de habilitacion para los registros de variables de entrada y para los valores de las variables despues de los primeros mux, respectivamente.\n.enab_d_ff_Xn(enab_d_ff4_Xn),\n.enab_d_ff_Yn(enab_d_ff4_Yn),\n.enab_d_ff_Zn(enab_d_ff4_Zn),\t//\tSeñales de habilitacion para los registros que guardan los resultados de cada variable en cada iteracion provenientes del modulo de suma/resta.\n.enab_d_ff_out(enab_d_ff5_data_out),\n.enab_dff_5(enab_dff_5),\t\t\t\t\t//\tSeñales de habilitacion para los registros en la salida, el primero antes del cambio de signo y el segundo es el que se encuentra en la salida.\n.enab_RB3(enab_RB3),\t\t\t\t\t//\tSeñales de habilitacion para los registros\tque guardan los valores provenientes de la look-up table y del signo, respectivamente.\n.enab_reg_sel_mux1(enab_reg_sel_mux1),\n.enab_reg_sel_mux2(enab_reg_sel_mux2),\n.enab_reg_sel_mux3(enab_reg_sel_mux3)\n);\n\ncounter_d #(.W(iter_bits)) cont_iter\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.load(load_cont_iter),\n.enable(enab_cont_iter),\n.d(d_iter),\n.max_tick(max_tick_iter),\n.min_tick(min_tick_iter),\n.q(cont_iter_out)\n);\n\ncounter_up #(.W(2)) cont_var\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.load(load_cont_var),\n.enable(enab_cont_var),\n.d(d_var),\n.max_tick(max_tick_var),\n.min_tick(min_tick_var),\n.q(cont_var_out)\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\n//Primera Etapa:  Registros que guardan los valores iniciales.\n\nd_ff_en\t# (.W(1)) reg_operation\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff_RB1), //load signal\n.D(operation), //input signal\n.Q(d_ff1_operation_out) //output signal\n);\n\nd_ff_en\t# (.W(2)) reg_region_flag\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff_RB1), //load signal\n.D(shift_region_flag), //input signal\n.Q(d_ff1_shift_region_flag_out) //output signal\n);\n\nd_ff_en\t# (.W(W)) reg_Z0\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff_RB1), //load signal\n.D(data_in), //input signal\n.Q(d_ff1_Z) //output signal\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------------------------------\n//Segunda Etapa : Registros que guardan el canal elegido para el mux, asi como los mux.\n\nd_ff_en\t# (.W(1)) reg_ch_mux_1\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_reg_sel_mux1), //load signal\n.D(sel_mux_1), //input signal\n.Q(sel_mux_1_reg) //output signal\n);\n\nMux_2x1 #(.W(W)) mux1_x0\n(\n.select(sel_mux_1_reg),\n.ch_0(x0),\n.ch_1(d_ff_Xn),\n.data_out(first_mux_X)\n);\n\nMux_2x1 #(.W(W)) mux1_y0\n(\n.select(sel_mux_1_reg),\n.ch_0(y0),\n.ch_1(d_ff_Yn),\n.data_out(first_mux_Y)\n);\n\nMux_2x1 #(.W(W)) mux1_z0\n(\n.select(sel_mux_1_reg),\n.ch_0(d_ff1_Z),\n.ch_1(d_ff_Zn),\n.data_out(first_mux_Z)\n);\n\n//----------------------------------------------------------------------------------------------------------------------\n//Tercera Etapa: Registros que guardan los datos provenientes de los mux.\n\nd_ff_en\t# (.W(W)) reg_val_muxX_2stage\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff2_RB2), //load signal\n.D(first_mux_X), //input signal\n.Q(d_ff2_X) //output signal\n);\n\nd_ff_en\t# (.W(W)) reg_val_muxY_2stage\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff2_RB2), //load signal\n.D(first_mux_Y), //input signal\n.Q(d_ff2_Y) //output signal\n);\n\nd_ff_en\t# (.W(W)) reg_val_muxZ_2stage\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_d_ff2_RB2), //load signal\n.D(first_mux_Z), //input signal\n.Q(d_ff2_Z) //output signal\n);\n\n//----------------------------------------------------------------------------------------------------------------------\n//Cuarta Etapa : Restadores para el corrimiento del exponente de X y Y, Lookup-Table y mux de signo dependiendo del modo.\n\nSimple_Subt #(.W(EW),.N(iter_bits)) shift_x\n(\n.A(d_ff2_X[W-2:SW]),\n.B(cont_iter_out),\n.Y(sh_exp_x)\n);\n\nSimple_Subt #(.W(EW),.N(iter_bits)) shift_y\n(\n.A(d_ff2_Y[W-2:SW]),\n.B(cont_iter_out),\n.Y(sh_exp_y)\n);\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\ngenerate\n    case(W)\n    32:\n    begin\n        LUT_ROM_32bits #(.W(W),.N(iter_bits)) LUT32\n        (\n        .address(cont_iter_out),\n        .data_out(data_out_LUT)\n        );\n    end\n    64:\n    begin        \n        LUT_ROM_64bits #(.W(W),.N(iter_bits)) LUT64\n        (\n        .address(cont_iter_out),\n        .data_out(data_out_LUT)\n        );\n    end\n    default:\n    begin\n        LUT_ROM_32bits #(.W(W),.N(iter_bits)) LUT32\n        (\n        .address(cont_iter_out),\n        .data_out(data_out_LUT)\n        );\n    end\n    endcase\nendgenerate\n\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nMux_2x1 #(.W(1)) mux_sign\n(\n.select(mode),\n.ch_0(d_ff2_Z[W-1]),\n.ch_1(d_ff2_Y[W-1]),\n.data_out(sign)\n);\n\n//-------------------------------------------------------------------------------------------------------------------------\n//Quinta Etapa : Registros que guardan los datos provenientes de la etapa anterior.\n\nd_ff_en\t# (.W(W)) reg_shift_x\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D({d_ff2_X[W-1],sh_exp_x,d_ff2_X[SW-1:0]}), //input signal\n.Q(d_ff3_sh_x_out) //output signal\n);\n\nd_ff_en\t# (.W(W)) reg_shift_y\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D({d_ff2_Y[W-1],sh_exp_y,d_ff2_Y[SW-1:0]}), //input signal\n.Q(d_ff3_sh_y_out) //output signal\n);\n\nd_ff_en\t# (.W(W)) reg_LUT\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D(data_out_LUT), //input signal\n.Q(d_ff3_LUT_out) //output signal\n);\n\nd_ff_en\t# (.W(1)) reg_sign\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_RB3), //load signal\n.D(sign), //input signal\n.Q(d_ff3_sign_out) //output signal\n);\n\n//-------------------------------------------------------------------------------------------------------------------------------------------------------\n//Sexta Etapa : Mux de 3 canales que se activan dependiendo de la variable a calcular.\n//Modificacion 18/8/2016 Muxes are elminated\n\nd_ff_en\t# (.W(2)) reg_ch_mux_2\n(\n.clk(clk),//system clock\n.rst(reset_reg_cordic), //system reset\n.enable(enab_reg_sel_mux2), //load signal\n.D(sel_mux_2), //input signal\n.Q(sel_mux_2_reg) //output signal\n);\n\n\n// Mux_3x1_b #(.W(W)) mux_3x1_var1\n// (\n// .select(sel_mux_2_reg),\n// .ch_0(d_ff2_X),\n// .ch_1(d_ff2_Y),\n// .ch_2(d_ff2_Z),\n// .data_out(add_subt_dataA)\n// );\n\n// Mux_3x1_b #(.W(W)) mux_3x1_var2\n// (\n// .select(sel_mux_2_reg),\n// .ch_0(d_ff3_sh_y_out),\n// .ch_1(d_ff3_sh_x_out),\n// .ch_2(d_ff3_LUT_out),\n// .data_out(add_subt_dataB)\n// );\n\nOp_Select\top_select_mod\n(\n.variable(cont_var_out[0]),\n.sign(d_ff3_sign_out),\n.operation(op_add_subt)\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------\n//Septima Etapa : Instanciamiento del módulo de suma y resta.\n//Modificacion 18/8/2016 2 FPU Adders are added for parallel operation.\n\nFPU_Add_Subtract_Function\t#(.W(W),.EW(EW),.SW(SW),.SWR(SWR),.EWR(EWR)) add_sub_Xn_Yshift\n(\n\t.clk(clk),\n\t.rst(rst),\n\t.beg_FSM(beg_add_subt),\n\t.ack_FSM(ack_add_subt),\n\t.Data_X(d_ff2_X),\n\t.Data_Y(d_ff3_sh_y_out),\n\t.add_subt(op_add_subt),\n\t.r_mode(r_mode),\n\t.overflow_flag(overflow_flag),\n\t.underflow_flag(underflow_flag),\n\t.ready(ready_add_subt),\n\t.final_result_ieee(result_add_subt)\n);\n\nFPU_Add_Subtract_Function\t#(.W(W),.EW(EW),.SW(SW),.SWR(SWR),.EWR(EWR)) add_sub_Yn_Xshift\n(\n\t.clk(clk),\n\t.rst(rst),\n\t.beg_FSM(beg_add_subt),\n\t.ack_FSM(ack_add_subt),\n\t.Data_X(d_ff2_Y),\n\t.Data_Y(d_ff3_sh_x_out),\n\t.add_subt(op_add_subt),\n\t.r_mode(r_mode),\n\t.overflow_flag(overflow_flag),\n\t.underflow_flag(underflow_flag),\n\t.ready(ready_add_subt),\n\t.final_result_ieee(result_add_subt)\n);\n\nFPU_Add_Subtract_Function\t#(.W(W),.EW(EW),.SW(SW),.SWR(SWR),.EWR(EWR)) add_sub_Zn_LUT\n(\n\t.clk(clk),\n\t.rst(rst),\n\t.beg_FSM(beg_add_subt),\n\t.ack_FSM(ack_add_subt),\n\t.Data_X(d_ff2_Z),\n\t.Data_Y(d_ff3_LUT_out),\n\t.add_subt(op_add_subt),\n\t.r_mode(r_mode),\n\t.overflow_flag(overflow_flag),\n\t.underflow_flag(underflow_flag),\n\t.ready(ready_add_subt),\n\t.final_result_ieee(result_add_subt)\n);\n//-------------------------------------------------------------------------------------------------------------------------------\n//Octava Etapa: Registros que guardan los valores de calculo del modulo de suma y resta.\n\nd_ff_en\t#(.W(W)) d_ff4_Xn\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff4_Xn),\n.D(result_add_subt),\n.Q(d_ff_Xn)\n);\n\nd_ff_en\t#(.W(W)) d_ff4_Yn\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff4_Yn),\n.D(result_add_subt),\n.Q(d_ff_Yn)\n);\n\nd_ff_en\t#(.W(W)) d_ff4_Zn\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff4_Zn),\n.D(result_add_subt),\n.Q(d_ff_Zn)\n);\n\n//--------------------------------------------------------------------------------------------------------------------------------\n//Novena Etapa: Mux de selección del valor de salida, así como el modulo de correccion de signo y los registros intermedios que\n//guardan los datos de salida.\n\nd_ff_en\t#(.W(1)) reg_ch_mux_3\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_reg_sel_mux3),\n.D(sel_mux_3),\n.Q(sel_mux_3_reg)\n);\n\nMux_2x1 #(.W(W)) mux_2x1_sal\n(\n.select(sel_mux_3_reg),\n.ch_0(d_ff_Xn),\n.ch_1(d_ff_Yn),\n.data_out(mux_sal)\n);\n\nd_ff_en\t#(.W(W)) d_ff5\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_dff_5),\n.D(mux_sal),\n.Q(data_output2)\n);\n\nsign_inverter #(.W(W)) sign_inverter_mod\n(\n.data(data_output2),\n.shift_region_flag(d_ff1_shift_region_flag_out),\n.operation(d_ff1_operation_out),\n.data_out(sign_inv_out)\n);\n\nd_ff_en\t#(.W(W)) d_ff5_data_out\n(\n.clk(clk),\n.rst(reset_reg_cordic),\n.enable(enab_d_ff5_data_out),\n.D(sign_inv_out),\n.Q(data_output)\n);\n\nendmodule\n",
			"file": "/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/new/CORDIC_Arch3.v",
			"file_size": 21520,
			"file_write_time": 131187074892014132,
			"settings":
			{
				"buffer_size": 21616,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
			"settings":
			{
				"buffer_size": 24367,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB.v",
			"settings":
			{
				"buffer_size": 20984,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Pipeline_FPADD_sourcefiles/shift_reg.v",
			"settings":
			{
				"buffer_size": 948,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/shift_reg.v",
			"settings":
			{
				"buffer_size": 952,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"contents": "`timescale 1ns / 1ps\n//////////////////////////////////////////////////////////////////////////////////\n// Company: \n// Engineer: \n// \n// Create Date: 03/12/2016 06:18:20 PM\n// Design Name: \n// Module Name: Mux_Array\n// Project Name: \n// Target Devices: \n// Tool Versions: \n// Description: \n// \n// Dependencies: \n// \n// Revision:\n// Revision 0.01 - File Created\n// Additional Comments:\n// \n//////////////////////////////////////////////////////////////////////////////////\n\n\nmodule Mux_Array\n    #(parameter SWR=26, parameter EWR=5)\n    (\n    input wire clk,\n    input wire rst,\n    input wire load_i,\n    input wire [SWR-1:0] Data_i,\n    input wire FSM_left_right_i,\n    input wire [EWR-1:0] Shift_Value_i,\n    input wire bit_shift_i,\n    output wire [SWR-1:0] Data_o\n    );\n////\nwire [SWR-1:0] Data_array[EWR+1:0];\n\n//////////////////7\ngenvar k;//Level\n///////////////////77777\nRotate_Mux_Array #(.SWR(SWR)) first_rotate(\n\t.Data_i(Data_i),\n\t.select_i(FSM_left_right_i),\n\t.Data_o(Data_array [0][SWR-1:0])\n\t);\ngenerate for (k=0; k < 3; k=k+1) begin\n\tshift_mux_array #(.SWR(SWR), .LEVEL(k)) shift_mux_array(\n\t\t.Data_i(Data_array[k]),\n\t\t.select_i(Shift_Value_i[k]),\n\t\t.bit_shift_i(bit_shift_i),\n\t\t.Data_o(Data_array[k+1])\n\t\t);\n\tend\nendgenerate\n\nRegisterAdd #(.W(SWR)) Mid_Reg(\n        .clk(clk),\n        .rst(rst),\n        .load(1'b1),\n        .D(Data_array[3]),\n        .Q(Data_array[4])\n        );\n\ngenerate for (k=3; k < EWR; k=k+1) begin\n\tshift_mux_array #(.SWR(SWR), .LEVEL(k)) shift_mux_array(\n\t\t.Data_i(Data_array[k+1]),\n\t\t.select_i(Shift_Value_i[k]),\n\t\t.bit_shift_i(bit_shift_i),\n\t\t.Data_o(Data_array[k+2])\n\t\t);\n\tend\nendgenerate\n\nRotate_Mux_Array #(.SWR(SWR)) last_rotate(\n\t.Data_i(Data_array[EWR+1]),\n\t.select_i(FSM_left_right_i),\n\t.Data_o(Data_o)\n\t);\n\t\n\n\t\nendmodule\n",
			"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/b_shifter_1.v",
			"file_size": 1774,
			"file_write_time": 131189172763759527,
			"settings":
			{
				"buffer_size": 1774,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "\n`timescale 1ns/1ps\n\nmodule tb_LUT_ROM_32bits (); /* this is automatically generated */\n\n\tlogic rstb;\n\tlogic srst;\n\tlogic clk;\n\n\t// clock\n\tinitial begin\n\t\tclk = 0;\n\t\tforever #5 clk = ~clk;\n\tend\n\n\t// reset\n\tinitial begin\n\t\trstb = 0;\n\t\tsrst = 0;\n\t\t#20\n\t\trstb = 1;\n\t\trepeat (5) @(posedge clk);\n\t\tsrst = 1;\n\t\trepeat (1) @(posedge clk);\n\t\tsrst = 0;\n\tend\n\n\t// (*NOTE*) replace reset, clock\n\n\tparameter W         = 32;\n\tparameter N         = 3;\n\tlocalparam ROM_FILE = \"LUT_sincos_32.txt\";\n\n\tlogic [N-1:0] address;\n\tlogic [W-1:0] data_out;\n\n\tLUT_ROM_32bits #(.W(W), .N(N)) inst_LUT_ROM_32bits (.address(address), .data_out(data_out));\n\n\tinitial begin\n\t\t// do something\n\n\t\trepeat(10)@(posedge clk);\n\t\t$finish;\n\tend\n\n\t// dump wave\n\tinitial begin\n\t\t$fsdbDumpfile(\"tb_LUT_ROM_32bits.fsdb\");\n\t\t$fsdbDumpvars(0, \"tb_LUT_ROM_32bits\", \"+mda\");\n\tend\n\nendmodule\n",
			"settings":
			{
				"buffer_size": 844,
				"line_ending": "Unix",
				"name": "tb_LUT_ROM_32bits.sv",
				"scratch": true
			}
		},
		{
			"contents": "`timescale 1ns / 1ps\n\nmodule LUT_ROM_32bits #(parameter W=32,N=3)\n(\n//Input Signals\ninput wire [N-1:0] address,\n//Output Signals\noutput reg [W-1:0] data_out\n);\nlocalparam ROM_FILE=\"LUT_sincos_32.txt\";\n\nreg [W-1:0] rom_test [2**N-1:0];\n initial\nbegin\n    $readmemh(ROM_FILE, rom_test, 0, 2**N-1);\nend\nalways @*\nbegin\n    data_out = rom_test[address];\nend\nendmodule\n",
			"settings":
			{
				"buffer_size": 364,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 319.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"isntall",
				"Package Control: Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"Snippet: ",
				"Snippet: forg"
			],
			[
				"package",
				"Package Control: Enable Package"
			]
		],
		"width": 402.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/bloody_simruns/behav/output_log.py",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/vector_simulation_add/imports/behav/Hexadecimal_B.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/TXTVerification/Hexadecimal_B.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/vector_simulation_add/behav/output_log.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/vector_simulation_add/behav/output_log.py",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/display.log",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Pipeline_FPADD_sourcefiles/shift_reg.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/project_1/archive_project_summary.txt",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Oper_Start_In.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FORMATTER.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/Tenth_Phase_v2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/task_FPADD_FPSUB.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_FUNCIONAL_v1/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Comparators.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/RegisterAdd.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Barrel_shifter.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Mux_Array.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/LZD.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/Shift_left_logical.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/usersnippet_verilogregister.sublime-snippet",
		"/home/jorge/.config/sublime-text-3/Packages/User/usersnippet_verilog.sublime-snippet",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Greater_Comparator.v",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/exp_operation.v",
		"/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/RegisterAdd.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/usersnippet_verilogcase3b.sublime-snippet",
		"/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
		"/home/jorge/.config/sublime-text-3/Packages/User/SublimeLinter.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/Package Control/Package Control.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/User/Distraction Free.sublime-settings",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FSM_Add_Subtract.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Barrel_Shifter_M.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Multiplexer_AC.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/imports/Sim/Sine_Cosine_CORDIC_tb.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/new/Testbench_FPU_Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/LUT_ROM_64bits.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/new/Testbench_LUT.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/LUT_ROM_32bits.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/counter_d.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/new/testbench_CORDICArch2.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/CORDIC_Arch2.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.sim/CORDIC_COS_32bits_round00/behav/CORDIC32_input_angles_dec.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/CORDIC_COS_32bits_round00/imports/COSENO",
		"/home/jorge/TESTING",
		"/home/jorge/FILES/CORDIC32_input_angles_dec.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/LUT_sincos_32.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/imports/ADD_SUB_Files/Hexadecimal_R.txt",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/imports/Floating-Point-Unit-master/Coprocesador_CORDIC_RTL/sine_cosine_CORDIC/d_ff_en.v",
		"/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sim_1/new/tb_CORDIC_Arch2.v",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Gadget/Verilog Gadget.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Gadget/Default (Linux).sublime-keymap",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Automatic/README.md",
		"/home/jorge/.config/sublime-text-3/Packages/User/Verilog Automatic.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Automatic/Verilog Automatic.sublime-settings",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v2.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Add_Subt.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/source/rtl/KOA_c_v3.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FPU_Multiplication_Function.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/sim/testbench_RKOA.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Sgf_Multiplication.v",
		"/home/jorge/Documents/Karatsuba_FPU/Karat/MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FPU_Multiplication_Function.v",
		"/home/jorge/.config/sublime-text-3/Packages/Verilog Automatic/Default (Linux).sublime-keymap",
		"/home/jorge/.config/sublime-text-3/Packages/User/Verilog.sublime-settings",
		"/home/jorge/.config/sublime-text-3/Packages/User/JSON.sublime-settings"
	],
	"find":
	{
		"height": 44.0
	},
	"find_in_files":
	{
		"height": 136.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"SIGN_FLAG_SHT1SHT2",
			"SIGN",
			"Exp_oper_1_EWR",
			"SIGN",
			"raw_Mantissa_SWR1",
			"Array_IN_3",
			"Array_IN_2",
			"fclose",
			"uut",
			"logVectorReference",
			"FPU_PIPELINED_FPADDSUB",
			"SIGN_FLAG_INIT",
			"sign_",
			"sign",
			"%8h",
			"%23h",
			"%26h",
			"%h",
			"\",",
			"\")",
			"\"",
			"\");",
			"FileSaveData",
			"$fwrite(\"",
			"display",
			")\n",
			"add_subt",
			"Shift_reg_FLAGS_7",
			"Shift_reg_FLAGS_6",
			"INPUT_ACTIVE",
			"ready",
			"Shift_reg_FLAGS_6",
			"FLAGS_OR",
			"Shift_reg_FLAGS",
			"LZD_raw_val_EWR",
			"SIGN_FLAG_SHT2",
			"ADD_OVRFLW_FRMT",
			"SIGN_FLAG_SHT1SHT2",
			"enable_input_internal",
			"ack_FSM",
			"beg_FSM",
			";\n",
			"ADD_OVRFLW_NRM",
			"ADD_OVRFLW",
			"Mantissa_M_SWR",
			"raw_Mantissa_SWR",
			"exp_oper_result",
			"LZD_raw_val_EWR",
			"Raw_mant_SGF",
			"Exponent_M_EW",
			"Mantissa_M_SW",
			"real_sign",
			"si",
			"Data_X",
			"add_subt",
			"enable_Pipeline_input",
			"task",
			"raw_Mantissa_SWR1",
			"exp_mux_D1",
			"Mantissa_M_SWR",
			"Mantissa_m_SWR",
			"raw_Mantissa_SWR1",
			"raw_Mantissa_SWR",
			"formatted_number",
			"DMP_EXP_EWSW",
			"intDY_W1",
			"intDX_W1",
			"intDY_W",
			"intDX_W",
			"formatted_number",
			"LZD_raw_output",
			"LZD_raw_output_NRM2",
			"LZD_output_NRM2",
			"Raw_mant_NRM",
			"Add_Subt_LZD",
			"DMP_exp_NRM",
			"DMP_mant_SFG",
			"DmP_mant_SFG",
			"DMP_exp_NRM2",
			"ADDSUB_exp_operand",
			"exp_rslt_NRM2",
			"Exp_oper_1",
			"sftr_odat_SHT2",
			"sftr_idat_SHT2",
			"shift_value_SHT2",
			"DMP_SHT2",
			"Data_array",
			"mux_sel_norm",
			"sftr_odat_SHT1",
			"sftr_idat_SHT1",
			"shft_value_mux_o",
			"Shift_amount_SHT1",
			"DmP_mant_SHT1",
			"DMP_SHT1",
			"b_shifter_one",
			"Shift_amount_EXP",
			"DmP_mant_EXP",
			"DMP_mant_EXP",
			"DmP_exp_EXP",
			"DMP_exp_EXP",
			"DmP_EXP",
			"DMP_EXP",
			"DmP_INIT_W_2",
			"DMP_INIT_W_2",
			"DmP_INIT",
			"DMP_INIT",
			"intDY",
			"intDX",
			"ADD_OVRFLW_FRMT",
			"ADD_OVRFLW_NRM",
			"ADD_OVRFLW_SGF",
			"add_ov",
			"LZD_raw_val_EW",
			"LZD_raw_val_EWR",
			"LZD_raw_val",
			"LZD_raw_output",
			"Exponent_diff",
			"Exponent_m",
			"Exponent_M",
			"Mantissa_m",
			"Mantissa_M",
			"Mantissa2",
			"Mantissa1",
			"Operand2",
			"Operand1",
			"Exponent2",
			"Exponent1",
			"raw_Mantissa"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"Exp_oper_1_EW",
			"uut",
			"0x%6h",
			"%0x6h",
			"0x%21h",
			"0x%24h",
			"0x%h",
			"\\n\",",
			"\\n\")",
			"\\n\"",
			"\"",
			"\n      $display(\"===============INIT STAGE: input signals============\");\n      $display(\"---------First Operator------------\");\n      $display(\"Mantissa = %23h, Exponent = %8h, sign = %d\", Mantissa1_SW, Exponent1_EW, Sign1);\n      $display(\"Mantissa = %b, Exponent = %b, sign = %b\", Mantissa1_SW, Exponent1_EW, Sign1);\n      $display(\"--------Second Operator------------\");\n      $display(\"Mantissa = %23h, Exponent = %8h, sign = %d\", Mantissa2_SW, Exponent2_EW, Sign2);\n      $display(\"Mantissa = %b, Exponent = %b, sign = %b\", Mantissa2_SW, Exponent2_EW, Sign2);\n",
			"\");",
			"\\n\");",
			"\");",
			"$fwrite(logVectorReference,\"",
			"fwrite",
			"Shift_reg_FLAGS_7",
			"Shift_reg_FLAGS_6",
			"Shift_reg_FLAGS",
			"ADD_OVRFLW_NRM2",
			"ADD_OVRFLW_FRMT",
			"enable_input_internal",
			"//ack_FSM",
			"beg_OP",
			"DMP_INIT_EWSW",
			"intDY_EWSW",
			"intDY_W1",
			"intDX_EWSW",
			"intDX_W1",
			"intDY_W1",
			"intDY_W",
			"intDX_W1",
			"intDX_W",
			"formatted_number_W",
			"formatted_number",
			"LZD_raw_out_EWR",
			"LZD_raw_output",
			"LZD_raw_out_NRM2_EWR",
			"LZD_raw_output_NRM2",
			"LZD_output_NRM2_EW",
			"LZD_output_NRM2",
			"Raw_mant_NRM_SWR",
			"Raw_mant_NRM",
			"wire [SWR-1:0] Raw_mant_NRM;\n",
			"Add_Subt_LZD_SWR",
			"Add_Subt_LZD",
			"DMP_exp_NRM_EW",
			"DMP_exp_NRM",
			"DMP_mant_SFG_SWR",
			"DmP_mant_SFG_SWR",
			"DmP_mant_SFG",
			"DMP_exp_NRM2_EW",
			"DMP_exp_NRM2",
			"ADDSUB_exp_operand_EW",
			"ADDSUB_exp_operand",
			"exp_rslt_NRM2_EW1",
			"exp_rslt_NRM2",
			"Exp_oper_1_EWR",
			"Exp_oper_1",
			"sftr_odat_SHT2_SWR",
			"sftr_odat_SHT2",
			"sftr_idat_SHT2_SWR",
			"sftr_idat_SHT2",
			"shift_value_SHT2_EWR",
			"shift_value_SHT2",
			"DMP_SHT2_EWSW",
			"DMP_SHT2",
			"Data_array_SWR",
			"Data_array",
			"mux_sel_norm_EWR",
			"mux_sel_norm",
			"sftr_odat_SHT1_SWR",
			"sftr_odat_SHT1",
			"sftr_idat_SHT1_SWR",
			"sftr_idat_SHT1",
			"shft_value_mux_o_EWR",
			"shft_value_mux_o",
			"Shift_amount_SHT1_EWR",
			"Shift_amount_SHT1",
			"DmP_mant_SHT1_SW",
			"DmP_mant_SHT1",
			"DMP_SHT1_EWSW",
			"DMP_SHT1",
			"b_shifter_one_SWR",
			"b_shifter_one",
			"Shift_amount_EXP_EW",
			"Shift_amount_EXP",
			"DmP_mant_EXP_SW",
			"DMP_mant_EXP_SW",
			"DMP_mant_EXP",
			"DmP_exp_EXP_EW",
			"DMP_exp_EXP_EW",
			"DMP_exp_EXP",
			"DmP_EXP_EWSW",
			"DmP_EXP",
			"wire [W-2:0] DMP_EXP_EWSW, DmP_EXP;\n",
			"DMP_EXP_EWSW",
			"DMP_EXP",
			"DmP_INIT_EWSW",
			"DMP_EXP_EWSW",
			"DmP_INIT_W_2",
			"DMP_INIT_W_2",
			"DMP_INIT_W.2",
			"DMP_INIT",
			"DMP_INIT_W_2",
			"DMP_INIT",
			"intDY_W",
			"intDX_W",
			"intDX",
			"LZD_raw_val_EWR",
			"LZD_raw_val_EW",
			"Exponent_diff_EW",
			"Exponent_m_EW",
			"Exponent_M_EW",
			"Mantissa_m_SW",
			"Mantissa_M_SW",
			"Mantissa2_SW",
			"Mantissa1_SW",
			"Operand2_W",
			"Operand1_W",
			"Exponent2_EW",
			"Exponent1_EW",
			"raw_Mantissa_SWR",
			"shft_value_mux_o",
			";",
			"EW",
			"UNDRFLW_FLAG_FRMT"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 35,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/new/Testbench_FPU_multiplication.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4541,
						"regions":
						{
						},
						"selection":
						[
							[
								2458,
								2458
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1316.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "source/rtl/FPU_Multiplication_Function_v2.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8447,
						"regions":
						{
						},
						"selection":
						[
							[
								495,
								495
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 70.0,
						"zoom_level": 1.0
					},
					"stack_index": 33,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/constrs_1/imports/RTL/Nexys4_Master.xdc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 37288,
						"regions":
						{
						},
						"selection":
						[
							[
								36804,
								36804
							]
						],
						"settings":
						{
							"syntax": "Packages/TCL/Tcl.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 10220.0,
						"zoom_level": 1.0
					},
					"stack_index": 34,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/constrs_1/new/Time_Constrains.xdc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2594,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/TCL/Tcl.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 35,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FPU_Multiplication_Function.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8367,
						"regions":
						{
						},
						"selection":
						[
							[
								6956,
								6956
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4900.0,
						"zoom_level": 1.0
					},
					"stack_index": 32,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12654,
						"regions":
						{
						},
						"selection":
						[
							[
								8872,
								8872
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4746.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/exp_operation.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2050,
						"regions":
						{
						},
						"selection":
						[
							[
								1584,
								1584
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 954.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Tenth_Phase.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2485,
						"regions":
						{
						},
						"selection":
						[
							[
								479,
								479
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 424.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FSM_Add_Subtract.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8944,
						"regions":
						{
						},
						"selection":
						[
							[
								1530,
								1530
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 5334.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/FPU_Add_Subtract_Function.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12627,
						"regions":
						{
						},
						"selection":
						[
							[
								12513,
								12513
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 6203.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sim_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Priority_Codec_32.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2322,
						"regions":
						{
						},
						"selection":
						[
							[
								483,
								483
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 280.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Add_Subt.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2538,
						"regions":
						{
						},
						"selection":
						[
							[
								1543,
								1543
							]
						],
						"settings":
						{
							"history_list_is_closing": true,
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 649.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/add_sub_carry_out.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 815,
						"regions":
						{
						},
						"selection":
						[
							[
								549,
								549
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/b_shifter_2.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1768,
						"regions":
						{
						},
						"selection":
						[
							[
								762,
								762
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 504.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/RegisterAdd.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 818,
						"regions":
						{
						},
						"selection":
						[
							[
								761,
								761
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 100.0,
						"zoom_level": 1.0
					},
					"stack_index": 29,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/MultiplexTxT.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 994,
						"regions":
						{
						},
						"selection":
						[
							[
								993,
								993
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 156.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Mux_3x1.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 799,
						"regions":
						{
						},
						"selection":
						[
							[
								657,
								657
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/fpuuart/FPU_UART.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4370,
						"regions":
						{
						},
						"selection":
						[
							[
								474,
								474
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/shift_mux.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1224,
						"regions":
						{
						},
						"selection":
						[
							[
								956,
								956
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 337.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Round_decoder_M.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 980,
						"regions":
						{
						},
						"selection":
						[
							[
								525,
								525
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 31,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/OR_Module.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 856,
						"regions":
						{
						},
						"selection":
						[
							[
								845,
								845
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 30,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "source/rtl/RecursiveKOA.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2468,
						"regions":
						{
						},
						"selection":
						[
							[
								535,
								535
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 117.0,
						"zoom_level": 1.0
					},
					"stack_index": 36,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/FSM_Mult_Function.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5817,
						"regions":
						{
						},
						"selection":
						[
							[
								5817,
								5817
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4060.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/RecursiveKOA.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2461,
						"regions":
						{
						},
						"selection":
						[
							[
								1504,
								1504
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 37,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v3.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6790,
						"regions":
						{
						},
						"selection":
						[
							[
								4732,
								4732
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1036.0,
						"zoom_level": 1.0
					},
					"stack_index": 43,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "source/rtl/KOA_c_v2.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9722,
						"regions":
						{
						},
						"selection":
						[
							[
								9722,
								9722
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 561.0,
						"zoom_level": 1.0
					},
					"stack_index": 38,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/rtl/KOA_c_v2.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9722,
						"regions":
						{
						},
						"selection":
						[
							[
								1081,
								1081
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3044.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 27,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Mult/Sgf_Multiplication.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10589,
						"regions":
						{
						},
						"selection":
						[
							[
								779,
								779
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 317.0,
						"zoom_level": 1.0
					},
					"stack_index": 39,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/new/Testbench_Sgf_multiplication.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1836,
						"regions":
						{
						},
						"selection":
						[
							[
								494,
								494
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 58.0,
						"zoom_level": 1.0
					},
					"stack_index": 40,
					"type": "text"
				},
				{
					"buffer": 29,
					"file": "MUL_FPU_FUNCIONAL_v1/MUL_FPU_FUNCIONAL_v1.srcs/sim_1/imports/sim/testbench_RKOA.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3845,
						"regions":
						{
						},
						"selection":
						[
							[
								2955,
								2955
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1918.0,
						"zoom_level": 1.0
					},
					"stack_index": 41,
					"type": "text"
				},
				{
					"buffer": 30,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Proyecto_De_Graduacion/FPU_FLM/RTL/Add-Subt/Multiplexer_AC.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 754,
						"regions":
						{
						},
						"selection":
						[
							[
								482,
								482
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 31,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FSM_input_enable.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3019,
						"regions":
						{
						},
						"selection":
						[
							[
								2864,
								2864
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1611.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 32,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/bloody_simruns/imports/behav/Hexadecimal_A.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9216,
						"regions":
						{
						},
						"selection":
						[
							[
								9,
								17
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 33,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/bloody_simruns/imports/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB2_vector_testing.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 34676,
						"regions":
						{
						},
						"selection":
						[
							[
								34644,
								34644
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 10048.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 34,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.sim/bloody_simruns/behav/output_log.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9534,
						"regions":
						{
						},
						"selection":
						[
							[
								9369,
								9369
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax"
						},
						"translation.x": 0.0,
						"translation.y": 2464.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 35,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24169,
						"regions":
						{
						},
						"selection":
						[
							[
								15461,
								15461
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7408.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 36,
					"file": "/home/jorge/Documents/Karatsuba_FPU/CORDICO/CORDICO.srcs/sources_1/new/CORDIC_Arch3.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21616,
						"regions":
						{
						},
						"selection":
						[
							[
								18155,
								18155
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 7154.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 37,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24367,
						"regions":
						{
							"bookmarks":
							{
								"flags": 144,
								"icon": "bookmark",
								"regions":
								[
									[
										24367,
										24367
									]
								],
								"scope": "bookmarks"
							}
						},
						"selection":
						[
							[
								24367,
								24367
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 11466.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 38,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/tb_FPU_PIPELINED_FPADDSUB.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20984,
						"regions":
						{
						},
						"selection":
						[
							[
								1801,
								1801
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1385.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 39,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Add_Sub/ADD_SUB_PIPELINED/ADD_SUB_FUNCIONAL_v1.srcs/sources_1/imports/Pipeline_FPADD_sourcefiles/shift_reg.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 948,
						"regions":
						{
						},
						"selection":
						[
							[
								562,
								562
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 40,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/shift_reg.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 952,
						"regions":
						{
						},
						"selection":
						[
							[
								815,
								815
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 41,
					"file": "/home/jorge/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/b_shifter_1.v",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1774,
						"regions":
						{
						},
						"selection":
						[
							[
								539,
								539
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 252.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 42,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 844,
						"regions":
						{
						},
						"selection":
						[
							[
								844,
								844
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 42,
					"type": "text"
				},
				{
					"buffer": 43,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 364,
						"regions":
						{
						},
						"selection":
						[
							[
								364,
								364
							]
						],
						"settings":
						{
							"syntax": "Packages/Verilog/Verilog.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 48.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.774001699235,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 116.0
	},
	"pinned_build_system": "",
	"project": "",
	"replace":
	{
		"height": 84.0
	},
	"save_all_on_build": false,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/Documents/Karatsuba_FPU/Pipeline_FPADD_sourcefiles/FPU_ADD_Substract_PIPELINED.v"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 322.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"Add_Subt"
			]
		],
		"width": 314.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 189.0,
	"status_bar_visible": true,
	"template_settings":
	{
		"max_columns": 2
	}
}
